{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nvar Op = Object.prototype;\nvar hasOwn = Op.hasOwnProperty;\n\nfunction pathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var isArray = types.builtInTypes.array;\n  var isNumber = types.builtInTypes.number;\n\n  var Path = function Path(value, parentPath, name) {\n    if (!(this instanceof Path)) {\n      throw new Error(\"Path constructor cannot be invoked without 'new'\");\n    }\n\n    if (parentPath) {\n      if (!(parentPath instanceof Path)) {\n        throw new Error(\"\");\n      }\n    } else {\n      parentPath = null;\n      name = null;\n    } // The value encapsulated by this Path, generally equal to\n    // parentPath.value[name] if we have a parentPath.\n\n\n    this.value = value; // The immediate parent Path of this Path.\n\n    this.parentPath = parentPath; // The name of the property of parentPath.value through which this\n    // Path's value was reached.\n\n    this.name = name; // Calling path.get(\"child\") multiple times always returns the same\n    // child Path object, for both performance and consistency reasons.\n\n    this.__childCache = null;\n  };\n\n  var Pp = Path.prototype;\n\n  function getChildCache(path) {\n    // Lazily create the child cache. This also cheapens cache\n    // invalidation, since you can just reset path.__childCache to null.\n    return path.__childCache || (path.__childCache = Object.create(null));\n  }\n\n  function getChildPath(path, name) {\n    var cache = getChildCache(path);\n    var actualChildValue = path.getValueProperty(name);\n    var childPath = cache[name];\n\n    if (!hasOwn.call(cache, name) || // Ensure consistency between cache and reality.\n    childPath.value !== actualChildValue) {\n      childPath = cache[name] = new path.constructor(actualChildValue, path, name);\n    }\n\n    return childPath;\n  } // This method is designed to be overridden by subclasses that need to\n  // handle missing properties, etc.\n\n\n  Pp.getValueProperty = function getValueProperty(name) {\n    return this.value[name];\n  };\n\n  Pp.get = function get() {\n    var names = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      names[_i] = arguments[_i];\n    }\n\n    var path = this;\n    var count = names.length;\n\n    for (var i = 0; i < count; ++i) {\n      path = getChildPath(path, names[i]);\n    }\n\n    return path;\n  };\n\n  Pp.each = function each(callback, context) {\n    var childPaths = [];\n    var len = this.value.length;\n    var i = 0; // Collect all the original child paths before invoking the callback.\n\n    for (var i = 0; i < len; ++i) {\n      if (hasOwn.call(this.value, i)) {\n        childPaths[i] = this.get(i);\n      }\n    } // Invoke the callback on just the original child paths, regardless of\n    // any modifications made to the array by the callback. I chose these\n    // semantics over cleverly invoking the callback on new elements because\n    // this way is much easier to reason about.\n\n\n    context = context || this;\n\n    for (i = 0; i < len; ++i) {\n      if (hasOwn.call(childPaths, i)) {\n        callback.call(context, childPaths[i]);\n      }\n    }\n  };\n\n  Pp.map = function map(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      result.push(callback.call(this, childPath));\n    }, context);\n    return result;\n  };\n\n  Pp.filter = function filter(callback, context) {\n    var result = [];\n    this.each(function (childPath) {\n      if (callback.call(this, childPath)) {\n        result.push(childPath);\n      }\n    }, context);\n    return result;\n  };\n\n  function emptyMoves() {}\n\n  function getMoves(path, offset, start, end) {\n    isArray.assert(path.value);\n\n    if (offset === 0) {\n      return emptyMoves;\n    }\n\n    var length = path.value.length;\n\n    if (length < 1) {\n      return emptyMoves;\n    }\n\n    var argc = arguments.length;\n\n    if (argc === 2) {\n      start = 0;\n      end = length;\n    } else if (argc === 3) {\n      start = Math.max(start, 0);\n      end = length;\n    } else {\n      start = Math.max(start, 0);\n      end = Math.min(end, length);\n    }\n\n    isNumber.assert(start);\n    isNumber.assert(end);\n    var moves = Object.create(null);\n    var cache = getChildCache(path);\n\n    for (var i = start; i < end; ++i) {\n      if (hasOwn.call(path.value, i)) {\n        var childPath = path.get(i);\n\n        if (childPath.name !== i) {\n          throw new Error(\"\");\n        }\n\n        var newIndex = i + offset;\n        childPath.name = newIndex;\n        moves[newIndex] = childPath;\n        delete cache[i];\n      }\n    }\n\n    delete cache.length;\n    return function () {\n      for (var newIndex in moves) {\n        var childPath = moves[newIndex];\n\n        if (childPath.name !== +newIndex) {\n          throw new Error(\"\");\n        }\n\n        cache[newIndex] = childPath;\n        path.value[newIndex] = childPath.value;\n      }\n    };\n  }\n\n  Pp.shift = function shift() {\n    var move = getMoves(this, -1);\n    var result = this.value.shift();\n    move();\n    return result;\n  };\n\n  Pp.unshift = function unshift() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var move = getMoves(this, args.length);\n    var result = this.value.unshift.apply(this.value, args);\n    move();\n    return result;\n  };\n\n  Pp.push = function push() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    isArray.assert(this.value);\n    delete getChildCache(this).length;\n    return this.value.push.apply(this.value, args);\n  };\n\n  Pp.pop = function pop() {\n    isArray.assert(this.value);\n    var cache = getChildCache(this);\n    delete cache[this.value.length - 1];\n    delete cache.length;\n    return this.value.pop();\n  };\n\n  Pp.insertAt = function insertAt(index) {\n    var argc = arguments.length;\n    var move = getMoves(this, argc - 1, index);\n\n    if (move === emptyMoves && argc <= 1) {\n      return this;\n    }\n\n    index = Math.max(index, 0);\n\n    for (var i = 1; i < argc; ++i) {\n      this.value[index + i - 1] = arguments[i];\n    }\n\n    move();\n    return this;\n  };\n\n  Pp.insertBefore = function insertBefore() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  Pp.insertAfter = function insertAfter() {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    var pp = this.parentPath;\n    var argc = args.length;\n    var insertAtArgs = [this.name + 1];\n\n    for (var i = 0; i < argc; ++i) {\n      insertAtArgs.push(args[i]);\n    }\n\n    return pp.insertAt.apply(pp, insertAtArgs);\n  };\n\n  function repairRelationshipWithParent(path) {\n    if (!(path instanceof Path)) {\n      throw new Error(\"\");\n    }\n\n    var pp = path.parentPath;\n\n    if (!pp) {\n      // Orphan paths have no relationship to repair.\n      return path;\n    }\n\n    var parentValue = pp.value;\n    var parentCache = getChildCache(pp); // Make sure parentCache[path.name] is populated.\n\n    if (parentValue[path.name] === path.value) {\n      parentCache[path.name] = path;\n    } else if (isArray.check(parentValue)) {\n      // Something caused path.name to become out of date, so attempt to\n      // recover by searching for path.value in parentValue.\n      var i = parentValue.indexOf(path.value);\n\n      if (i >= 0) {\n        parentCache[path.name = i] = path;\n      }\n    } else {\n      // If path.value disagrees with parentValue[path.name], and\n      // path.name is not an array index, let path.value become the new\n      // parentValue[path.name] and update parentCache accordingly.\n      parentValue[path.name] = path.value;\n      parentCache[path.name] = path;\n    }\n\n    if (parentValue[path.name] !== path.value) {\n      throw new Error(\"\");\n    }\n\n    if (path.parentPath.get(path.name) !== path) {\n      throw new Error(\"\");\n    }\n\n    return path;\n  }\n\n  Pp.replace = function replace(replacement) {\n    var results = [];\n    var parentValue = this.parentPath.value;\n    var parentCache = getChildCache(this.parentPath);\n    var count = arguments.length;\n    repairRelationshipWithParent(this);\n\n    if (isArray.check(parentValue)) {\n      var originalLength = parentValue.length;\n      var move = getMoves(this.parentPath, count - 1, this.name + 1);\n      var spliceArgs = [this.name, 1];\n\n      for (var i = 0; i < count; ++i) {\n        spliceArgs.push(arguments[i]);\n      }\n\n      var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);\n\n      if (splicedOut[0] !== this.value) {\n        throw new Error(\"\");\n      }\n\n      if (parentValue.length !== originalLength - 1 + count) {\n        throw new Error(\"\");\n      }\n\n      move();\n\n      if (count === 0) {\n        delete this.value;\n        delete parentCache[this.name];\n        this.__childCache = null;\n      } else {\n        if (parentValue[this.name] !== replacement) {\n          throw new Error(\"\");\n        }\n\n        if (this.value !== replacement) {\n          this.value = replacement;\n          this.__childCache = null;\n        }\n\n        for (i = 0; i < count; ++i) {\n          results.push(this.parentPath.get(this.name + i));\n        }\n\n        if (results[0] !== this) {\n          throw new Error(\"\");\n        }\n      }\n    } else if (count === 1) {\n      if (this.value !== replacement) {\n        this.__childCache = null;\n      }\n\n      this.value = parentValue[this.name] = replacement;\n      results.push(this);\n    } else if (count === 0) {\n      delete parentValue[this.name];\n      delete this.value;\n      this.__childCache = null; // Leave this path cached as parentCache[this.name], even though\n      // it no longer has a value defined.\n    } else {\n      throw new Error(\"Could not replace path\");\n    }\n\n    return results;\n  };\n\n  return Path;\n}\n\nexports.default = pathPlugin;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}