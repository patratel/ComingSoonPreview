{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar core_1 = __importDefault(require(\"./core\"));\n\nvar types_1 = __importDefault(require(\"../lib/types\"));\n\nvar shared_1 = __importDefault(require(\"../lib/shared\"));\n\nfunction default_1(fork) {\n  fork.use(core_1.default);\n  var types = fork.use(types_1.default);\n  var def = types.Type.def;\n  var or = types.Type.or;\n  var defaults = fork.use(shared_1.default).defaults;\n  def(\"Function\").field(\"generator\", Boolean, defaults[\"false\"]).field(\"expression\", Boolean, defaults[\"false\"]).field(\"defaults\", [or(def(\"Expression\"), null)], defaults.emptyArray) // TODO This could be represented as a RestElement in .params.\n  .field(\"rest\", or(def(\"Identifier\"), null), defaults[\"null\"]); // The ESTree way of representing a ...rest parameter.\n\n  def(\"RestElement\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\")).field(\"typeAnnotation\", // for Babylon. Flow parser puts it on the identifier\n  or(def(\"TypeAnnotation\"), def(\"TSTypeAnnotation\"), null), defaults[\"null\"]);\n  def(\"SpreadElementPattern\").bases(\"Pattern\").build(\"argument\").field(\"argument\", def(\"Pattern\"));\n  def(\"FunctionDeclaration\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\");\n  def(\"FunctionExpression\").build(\"id\", \"params\", \"body\", \"generator\", \"expression\"); // The Parser API calls this ArrowExpression, but Esprima and all other\n  // actual parsers use ArrowFunctionExpression.\n\n  def(\"ArrowFunctionExpression\").bases(\"Function\", \"Expression\").build(\"params\", \"body\", \"expression\") // The forced null value here is compatible with the overridden\n  // definition of the \"id\" field in the Function interface.\n  .field(\"id\", null, defaults[\"null\"]) // Arrow function bodies are allowed to be expressions.\n  .field(\"body\", or(def(\"BlockStatement\"), def(\"Expression\"))) // The current spec forbids arrow generators, so I have taken the\n  // liberty of enforcing that. TODO Report this.\n  .field(\"generator\", false, defaults[\"false\"]);\n  def(\"ForOfStatement\").bases(\"Statement\").build(\"left\", \"right\", \"body\").field(\"left\", or(def(\"VariableDeclaration\"), def(\"Pattern\"))).field(\"right\", def(\"Expression\")).field(\"body\", def(\"Statement\"));\n  def(\"YieldExpression\").bases(\"Expression\").build(\"argument\", \"delegate\").field(\"argument\", or(def(\"Expression\"), null)).field(\"delegate\", Boolean, defaults[\"false\"]);\n  def(\"GeneratorExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionExpression\").bases(\"Expression\").build(\"body\", \"blocks\", \"filter\").field(\"body\", def(\"Expression\")).field(\"blocks\", [def(\"ComprehensionBlock\")]).field(\"filter\", or(def(\"Expression\"), null));\n  def(\"ComprehensionBlock\").bases(\"Node\").build(\"left\", \"right\", \"each\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\")).field(\"each\", Boolean);\n  def(\"Property\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"value\", or(def(\"Expression\"), def(\"Pattern\"))).field(\"method\", Boolean, defaults[\"false\"]).field(\"shorthand\", Boolean, defaults[\"false\"]).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectProperty\").field(\"shorthand\", Boolean, defaults[\"false\"]);\n  def(\"PropertyPattern\").bases(\"Pattern\").build(\"key\", \"pattern\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"pattern\", def(\"Pattern\")).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ObjectPattern\").bases(\"Pattern\").build(\"properties\").field(\"properties\", [or(def(\"PropertyPattern\"), def(\"Property\"))]);\n  def(\"ArrayPattern\").bases(\"Pattern\").build(\"elements\").field(\"elements\", [or(def(\"Pattern\"), null)]);\n  def(\"MethodDefinition\").bases(\"Declaration\").build(\"kind\", \"key\", \"value\", \"static\").field(\"kind\", or(\"constructor\", \"method\", \"get\", \"set\")).field(\"key\", def(\"Expression\")).field(\"value\", def(\"Function\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"static\", Boolean, defaults[\"false\"]);\n  def(\"SpreadElement\").bases(\"Node\").build(\"argument\").field(\"argument\", def(\"Expression\"));\n  def(\"ArrayExpression\").field(\"elements\", [or(def(\"Expression\"), def(\"SpreadElement\"), def(\"RestElement\"), null)]);\n  def(\"NewExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]);\n  def(\"CallExpression\").field(\"arguments\", [or(def(\"Expression\"), def(\"SpreadElement\"))]); // Note: this node type is *not* an AssignmentExpression with a Pattern on\n  // the left-hand side! The existing AssignmentExpression type already\n  // supports destructuring assignments. AssignmentPattern nodes may appear\n  // wherever a Pattern is allowed, and the right-hand side represents a\n  // default value to be destructured against the left-hand side, if no\n  // value is otherwise provided. For example: default parameter values.\n\n  def(\"AssignmentPattern\").bases(\"Pattern\").build(\"left\", \"right\").field(\"left\", def(\"Pattern\")).field(\"right\", def(\"Expression\"));\n  var ClassBodyElement = or(def(\"MethodDefinition\"), def(\"VariableDeclarator\"), def(\"ClassPropertyDefinition\"), def(\"ClassProperty\"));\n  def(\"ClassProperty\").bases(\"Declaration\").build(\"key\").field(\"key\", or(def(\"Literal\"), def(\"Identifier\"), def(\"Expression\"))).field(\"computed\", Boolean, defaults[\"false\"]);\n  def(\"ClassPropertyDefinition\") // static property\n  .bases(\"Declaration\").build(\"definition\") // Yes, Virginia, circular definitions are permitted.\n  .field(\"definition\", ClassBodyElement);\n  def(\"ClassBody\").bases(\"Declaration\").build(\"body\").field(\"body\", [ClassBodyElement]);\n  def(\"ClassDeclaration\").bases(\"Declaration\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null)).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"ClassExpression\").bases(\"Expression\").build(\"id\", \"body\", \"superClass\").field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"body\", def(\"ClassBody\")).field(\"superClass\", or(def(\"Expression\"), null), defaults[\"null\"]); // Specifier and ModuleSpecifier are abstract non-standard types\n  // introduced for definitional convenience.\n\n  def(\"Specifier\").bases(\"Node\"); // This supertype is shared/abused by both def/babel.js and\n  // def/esprima.js. In the future, it will be possible to load only one set\n  // of definitions appropriate for a given parser, but until then we must\n  // rely on default functions to reconcile the conflicting AST formats.\n\n  def(\"ModuleSpecifier\").bases(\"Specifier\") // This local field is used by Babel/Acorn. It should not technically\n  // be optional in the Babel/Acorn AST format, but it must be optional\n  // in the Esprima AST format.\n  .field(\"local\", or(def(\"Identifier\"), null), defaults[\"null\"]) // The id and name fields are used by Esprima. The id field should not\n  // technically be optional in the Esprima AST format, but it must be\n  // optional in the Babel/Acorn AST format.\n  .field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"name\", or(def(\"Identifier\"), null), defaults[\"null\"]); // Like ModuleSpecifier, except type:\"ImportSpecifier\" and buildable.\n  // import {<id [as name]>} from ...;\n\n  def(\"ImportSpecifier\").bases(\"ModuleSpecifier\").build(\"id\", \"name\"); // import <* as id> from ...;\n\n  def(\"ImportNamespaceSpecifier\").bases(\"ModuleSpecifier\").build(\"id\"); // import <id> from ...;\n\n  def(\"ImportDefaultSpecifier\").bases(\"ModuleSpecifier\").build(\"id\");\n  def(\"ImportDeclaration\").bases(\"Declaration\").build(\"specifiers\", \"source\", \"importKind\").field(\"specifiers\", [or(def(\"ImportSpecifier\"), def(\"ImportNamespaceSpecifier\"), def(\"ImportDefaultSpecifier\"))], defaults.emptyArray).field(\"source\", def(\"Literal\")).field(\"importKind\", or(\"value\", \"type\"), function () {\n    return \"value\";\n  });\n  def(\"TaggedTemplateExpression\").bases(\"Expression\").build(\"tag\", \"quasi\").field(\"tag\", def(\"Expression\")).field(\"quasi\", def(\"TemplateLiteral\"));\n  def(\"TemplateLiteral\").bases(\"Expression\").build(\"quasis\", \"expressions\").field(\"quasis\", [def(\"TemplateElement\")]).field(\"expressions\", [def(\"Expression\")]);\n  def(\"TemplateElement\").bases(\"Node\").build(\"value\", \"tail\").field(\"value\", {\n    \"cooked\": String,\n    \"raw\": String\n  }).field(\"tail\", Boolean);\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}