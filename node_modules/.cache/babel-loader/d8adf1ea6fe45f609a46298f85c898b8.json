{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var getFieldNames = types.getFieldNames;\n  var getFieldValue = types.getFieldValue;\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isDate = types.builtInTypes.Date;\n  var isRegExp = types.builtInTypes.RegExp;\n  var hasOwn = Object.prototype.hasOwnProperty;\n\n  function astNodesAreEquivalent(a, b, problemPath) {\n    if (isArray.check(problemPath)) {\n      problemPath.length = 0;\n    } else {\n      problemPath = null;\n    }\n\n    return areEquivalent(a, b, problemPath);\n  }\n\n  astNodesAreEquivalent.assert = function (a, b) {\n    var problemPath = [];\n\n    if (!astNodesAreEquivalent(a, b, problemPath)) {\n      if (problemPath.length === 0) {\n        if (a !== b) {\n          throw new Error(\"Nodes must be equal\");\n        }\n      } else {\n        throw new Error(\"Nodes differ in the following path: \" + problemPath.map(subscriptForProperty).join(\"\"));\n      }\n    }\n  };\n\n  function subscriptForProperty(property) {\n    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n      return \".\" + property;\n    }\n\n    return \"[\" + JSON.stringify(property) + \"]\";\n  }\n\n  function areEquivalent(a, b, problemPath) {\n    if (a === b) {\n      return true;\n    }\n\n    if (isArray.check(a)) {\n      return arraysAreEquivalent(a, b, problemPath);\n    }\n\n    if (isObject.check(a)) {\n      return objectsAreEquivalent(a, b, problemPath);\n    }\n\n    if (isDate.check(a)) {\n      return isDate.check(b) && +a === +b;\n    }\n\n    if (isRegExp.check(a)) {\n      return isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;\n    }\n\n    return a == b;\n  }\n\n  function arraysAreEquivalent(a, b, problemPath) {\n    isArray.assert(a);\n    var aLength = a.length;\n\n    if (!isArray.check(b) || b.length !== aLength) {\n      if (problemPath) {\n        problemPath.push(\"length\");\n      }\n\n      return false;\n    }\n\n    for (var i = 0; i < aLength; ++i) {\n      if (problemPath) {\n        problemPath.push(i);\n      }\n\n      if (i in a !== i in b) {\n        return false;\n      }\n\n      if (!areEquivalent(a[i], b[i], problemPath)) {\n        return false;\n      }\n\n      if (problemPath) {\n        var problemPathTail = problemPath.pop();\n\n        if (problemPathTail !== i) {\n          throw new Error(\"\" + problemPathTail);\n        }\n      }\n    }\n\n    return true;\n  }\n\n  function objectsAreEquivalent(a, b, problemPath) {\n    isObject.assert(a);\n\n    if (!isObject.check(b)) {\n      return false;\n    } // Fast path for a common property of AST nodes.\n\n\n    if (a.type !== b.type) {\n      if (problemPath) {\n        problemPath.push(\"type\");\n      }\n\n      return false;\n    }\n\n    var aNames = getFieldNames(a);\n    var aNameCount = aNames.length;\n    var bNames = getFieldNames(b);\n    var bNameCount = bNames.length;\n\n    if (aNameCount === bNameCount) {\n      for (var i = 0; i < aNameCount; ++i) {\n        var name = aNames[i];\n        var aChild = getFieldValue(a, name);\n        var bChild = getFieldValue(b, name);\n\n        if (problemPath) {\n          problemPath.push(name);\n        }\n\n        if (!areEquivalent(aChild, bChild, problemPath)) {\n          return false;\n        }\n\n        if (problemPath) {\n          var problemPathTail = problemPath.pop();\n\n          if (problemPathTail !== name) {\n            throw new Error(\"\" + problemPathTail);\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (!problemPath) {\n      return false;\n    } // Since aNameCount !== bNameCount, we need to find some name that's\n    // missing in aNames but present in bNames, or vice-versa.\n\n\n    var seenNames = Object.create(null);\n\n    for (i = 0; i < aNameCount; ++i) {\n      seenNames[aNames[i]] = true;\n    }\n\n    for (i = 0; i < bNameCount; ++i) {\n      name = bNames[i];\n\n      if (!hasOwn.call(seenNames, name)) {\n        problemPath.push(name);\n        return false;\n      }\n\n      delete seenNames[name];\n    }\n\n    for (name in seenNames) {\n      problemPath.push(name);\n      break;\n    }\n\n    return false;\n  }\n\n  return astNodesAreEquivalent;\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}