{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar tls; // lazy-loaded...\n\nvar url = require('url');\n\nvar dns = require('dns');\n\nvar Agent = require('agent-base');\n\nvar SocksClient = require('socks');\n\nvar inherits = require('util').inherits;\n/**\n * Module exports.\n */\n\n\nmodule.exports = SocksProxyAgent;\n/**\n * The `SocksProxyAgent`.\n *\n * @api public\n */\n\nfunction SocksProxyAgent(opts) {\n  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('a SOCKS proxy server `host` and `port` must be specified!');\n  Agent.call(this, opts);\n  var proxy = Object.assign({}, opts); // prefer `hostname` over `host`, because of `url.parse()`\n\n  proxy.host = proxy.hostname || proxy.host; // SOCKS doesn't *technically* have a default port, but this is\n  // the same default that `curl(1)` uses\n\n  proxy.port = +proxy.port || 1080;\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  } // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n  // Defaults to 5.\n\n\n  proxy.lookup = false;\n\n  switch (proxy.protocol) {\n    case 'socks4:':\n      proxy.lookup = true;\n    // pass through\n\n    case 'socks4a:':\n      proxy.version = 4;\n      break;\n\n    case 'socks5:':\n      proxy.lookup = true;\n    // pass through\n\n    case 'socks:': // no version specified, default to 5h\n\n    case 'socks5h:':\n      proxy.version = 5;\n      break;\n\n    default:\n      throw new TypeError('A \"socks\" protocol must be specified! Got: ' + proxy.protocol);\n  }\n\n  if (proxy.auth) {\n    var auth = proxy.auth.split(':');\n    proxy.authentication = {\n      username: auth[0],\n      password: auth[1]\n    };\n    proxy.userid = auth[0];\n  }\n\n  this.proxy = proxy;\n}\n\ninherits(SocksProxyAgent, Agent);\n/**\n * Initiates a SOCKS connection to the specified SOCKS proxy server,\n * which in turn connects to the specified remote host and port.\n *\n * @api public\n */\n\nSocksProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy; // called once the SOCKS proxy has connected to the specified remote endpoint\n\n  function onhostconnect(err, socket) {\n    if (err) return fn(err);\n    var s = socket;\n\n    if (opts.secureEndpoint) {\n      // since the proxy is connecting to an SSL server, we have\n      // to upgrade this socket connection to an SSL connection\n      if (!tls) tls = require('tls');\n      opts.socket = socket;\n      opts.servername = opts.host;\n      opts.host = null;\n      opts.hostname = null;\n      opts.port = null;\n      s = tls.connect(opts);\n    }\n\n    socket.resume();\n    fn(null, s);\n  } // called for the `dns.lookup()` callback\n\n\n  function onlookup(err, ip) {\n    if (err) return fn(err);\n    options.target.host = ip;\n    SocksClient.createConnection(options, onhostconnect);\n  }\n\n  var options = {\n    proxy: {\n      ipaddress: proxy.host,\n      port: +proxy.port,\n      type: proxy.version\n    },\n    target: {\n      port: +opts.port\n    },\n    command: 'connect'\n  };\n\n  if (proxy.authentication) {\n    options.proxy.authentication = proxy.authentication;\n    options.proxy.userid = proxy.userid;\n  }\n\n  if (proxy.lookup) {\n    // client-side DNS resolution for \"4\" and \"5\" socks proxy versions\n    dns.lookup(opts.host, onlookup);\n  } else {\n    // proxy hostname DNS resolution for \"4a\" and \"5h\" socks proxy servers\n    onlookup(null, opts.host);\n  }\n};","map":null,"metadata":{},"sourceType":"script"}