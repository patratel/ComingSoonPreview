{"ast":null,"code":"var fs = require('fs'),\n    tls = require('tls'),\n    zlib = require('zlib'),\n    Socket = require('net').Socket,\n    EventEmitter = require('events').EventEmitter,\n    inherits = require('util').inherits,\n    inspect = require('util').inspect;\n\nvar Parser = require('./parser');\n\nvar XRegExp = require('xregexp').XRegExp;\n\nvar REX_TIMEVAL = XRegExp.cache('^(?<year>\\\\d{4})(?<month>\\\\d{2})(?<date>\\\\d{2})(?<hour>\\\\d{2})(?<minute>\\\\d{2})(?<second>\\\\d+)(?:.\\\\d+)?$'),\n    RE_PASV = /([\\d]+),([\\d]+),([\\d]+),([\\d]+),([-\\d]+),([-\\d]+)/,\n    RE_EOL = /\\r?\\n/g,\n    RE_WD = /\"(.+)\"(?: |$)/,\n    RE_SYST = /^([^ ]+)(?: |$)/;\nvar\n/*TYPE = {\n  SYNTAX: 0,\n  INFO: 1,\n  SOCKETS: 2,\n  AUTH: 3,\n  UNSPEC: 4,\n  FILESYS: 5\n},*/\nRETVAL = {\n  PRELIM: 1,\n  OK: 2,\n  WAITING: 3,\n  ERR_TEMP: 4,\n  ERR_PERM: 5\n},\n\n/*ERRORS = {\n  421: 'Service not available, closing control connection',\n  425: 'Can\\'t open data connection',\n  426: 'Connection closed; transfer aborted',\n  450: 'Requested file action not taken / File unavailable (e.g., file busy)',\n  451: 'Requested action aborted: local error in processing',\n  452: 'Requested action not taken / Insufficient storage space in system',\n  500: 'Syntax error / Command unrecognized',\n  501: 'Syntax error in parameters or arguments',\n  502: 'Command not implemented',\n  503: 'Bad sequence of commands',\n  504: 'Command not implemented for that parameter',\n  530: 'Not logged in',\n  532: 'Need account for storing files',\n  550: 'Requested action not taken / File unavailable (e.g., file not found, no access)',\n  551: 'Requested action aborted: page type unknown',\n  552: 'Requested file action aborted / Exceeded storage allocation (for current directory or dataset)',\n  553: 'Requested action not taken / File name not allowed'\n},*/\nbytesNOOP = new Buffer('NOOP\\r\\n');\n\nvar FTP = module.exports = function () {\n  if (!(this instanceof FTP)) return new FTP();\n  this._socket = undefined;\n  this._pasvSock = undefined;\n  this._feat = undefined;\n  this._curReq = undefined;\n  this._queue = [];\n  this._secstate = undefined;\n  this._debug = undefined;\n  this._keepalive = undefined;\n  this._ending = false;\n  this._parser = undefined;\n  this.options = {\n    host: undefined,\n    port: undefined,\n    user: undefined,\n    password: undefined,\n    secure: false,\n    secureOptions: undefined,\n    connTimeout: undefined,\n    pasvTimeout: undefined,\n    aliveTimeout: undefined\n  };\n  this.connected = false;\n};\n\ninherits(FTP, EventEmitter);\n\nFTP.prototype.connect = function (options) {\n  var self = this;\n  if (typeof options !== 'object') options = {};\n  this.connected = false;\n  this.options.host = options.host || 'localhost';\n  this.options.port = options.port || 21;\n  this.options.user = options.user || 'anonymous';\n  this.options.password = options.password || 'anonymous@';\n  this.options.secure = options.secure || false;\n  this.options.secureOptions = options.secureOptions;\n  this.options.connTimeout = options.connTimeout || 10000;\n  this.options.pasvTimeout = options.pasvTimeout || 10000;\n  this.options.aliveTimeout = options.keepalive || 10000;\n  if (typeof options.debug === 'function') this._debug = options.debug;\n  var secureOptions,\n      debug = this._debug,\n      socket = new Socket();\n  socket.setTimeout(0);\n  socket.setKeepAlive(true);\n  this._parser = new Parser({\n    debug: debug\n  });\n\n  this._parser.on('response', function (code, text) {\n    var retval = code / 100 >> 0;\n\n    if (retval === RETVAL.ERR_TEMP || retval === RETVAL.ERR_PERM) {\n      if (self._curReq) self._curReq.cb(makeError(code, text), undefined, code);else self.emit('error', makeError(code, text));\n    } else if (self._curReq) self._curReq.cb(undefined, text, code); // a hack to signal we're waiting for a PASV data connection to complete\n    // first before executing any more queued requests ...\n    //\n    // also: don't forget our current request if we're expecting another\n    // terminating response ....\n\n\n    if (self._curReq && retval !== RETVAL.PRELIM) {\n      self._curReq = undefined;\n\n      self._send();\n    }\n\n    noopreq.cb();\n  });\n\n  if (this.options.secure) {\n    secureOptions = {};\n    secureOptions.host = this.options.host;\n\n    for (var k in this.options.secureOptions) secureOptions[k] = this.options.secureOptions[k];\n\n    secureOptions.socket = socket;\n    this.options.secureOptions = secureOptions;\n  }\n\n  if (this.options.secure === 'implicit') this._socket = tls.connect(secureOptions, onconnect);else {\n    socket.once('connect', onconnect);\n    this._socket = socket;\n  }\n  var noopreq = {\n    cmd: 'NOOP',\n    cb: function () {\n      clearTimeout(self._keepalive);\n      self._keepalive = setTimeout(donoop, self.options.aliveTimeout);\n    }\n  };\n\n  function donoop() {\n    if (!self._socket || !self._socket.writable) clearTimeout(self._keepalive);else if (!self._curReq && self._queue.length === 0) {\n      self._curReq = noopreq;\n      debug && debug('[connection] > NOOP');\n\n      self._socket.write(bytesNOOP);\n    } else noopreq.cb();\n  }\n\n  function onconnect() {\n    clearTimeout(timer);\n    clearTimeout(self._keepalive);\n    self.connected = true;\n    self._socket = socket; // re-assign for implicit secure connections\n\n    var cmd;\n\n    if (self._secstate) {\n      if (self._secstate === 'upgraded-tls' && self.options.secure === true) {\n        cmd = 'PBSZ';\n\n        self._send('PBSZ 0', reentry, true);\n      } else {\n        cmd = 'USER';\n\n        self._send('USER ' + self.options.user, reentry, true);\n      }\n    } else {\n      self._curReq = {\n        cmd: '',\n        cb: reentry\n      };\n    }\n\n    function reentry(err, text, code) {\n      if (err && (!cmd || cmd === 'USER' || cmd === 'PASS' || cmd === 'TYPE')) {\n        self.emit('error', err);\n        return self._socket && self._socket.end();\n      }\n\n      if (cmd === 'AUTH TLS' && code !== 234 && self.options.secure !== true || cmd === 'AUTH SSL' && code !== 334 || cmd === 'PBSZ' && code !== 200 || cmd === 'PROT' && code !== 200) {\n        self.emit('error', makeError(code, 'Unable to secure connection(s)'));\n        return self._socket && self._socket.end();\n      }\n\n      if (!cmd) {\n        // sometimes the initial greeting can contain useful information\n        // about authorized use, other limits, etc.\n        self.emit('greeting', text);\n\n        if (self.options.secure && self.options.secure !== 'implicit') {\n          cmd = 'AUTH TLS';\n\n          self._send(cmd, reentry, true);\n        } else {\n          cmd = 'USER';\n\n          self._send('USER ' + self.options.user, reentry, true);\n        }\n      } else if (cmd === 'USER') {\n        if (code !== 230) {\n          // password required\n          if (!self.options.password) {\n            self.emit('error', makeError(code, 'Password required'));\n            return self._socket && self._socket.end();\n          }\n\n          cmd = 'PASS';\n\n          self._send('PASS ' + self.options.password, reentry, true);\n        } else {\n          // no password required\n          cmd = 'PASS';\n          reentry(undefined, text, code);\n        }\n      } else if (cmd === 'PASS') {\n        cmd = 'FEAT';\n\n        self._send(cmd, reentry, true);\n      } else if (cmd === 'FEAT') {\n        if (!err) self._feat = Parser.parseFeat(text);\n        cmd = 'TYPE';\n\n        self._send('TYPE I', reentry, true);\n      } else if (cmd === 'TYPE') self.emit('ready');else if (cmd === 'PBSZ') {\n        cmd = 'PROT';\n\n        self._send('PROT P', reentry, true);\n      } else if (cmd === 'PROT') {\n        cmd = 'USER';\n\n        self._send('USER ' + self.options.user, reentry, true);\n      } else if (cmd.substr(0, 4) === 'AUTH') {\n        if (cmd === 'AUTH TLS' && code !== 234) {\n          cmd = 'AUTH SSL';\n          return self._send(cmd, reentry, true);\n        } else if (cmd === 'AUTH TLS') self._secstate = 'upgraded-tls';else if (cmd === 'AUTH SSL') self._secstate = 'upgraded-ssl';\n\n        socket.removeAllListeners('data');\n        socket.removeAllListeners('error');\n        socket._decoder = null;\n        self._curReq = null; // prevent queue from being processed during\n        // TLS/SSL negotiation\n\n        secureOptions.socket = self._socket;\n        secureOptions.session = undefined;\n        socket = tls.connect(secureOptions, onconnect);\n        socket.setEncoding('binary');\n        socket.on('data', ondata);\n        socket.once('end', onend);\n        socket.on('error', onerror);\n      }\n    }\n  }\n\n  socket.on('data', ondata);\n\n  function ondata(chunk) {\n    debug && debug('[connection] < ' + inspect(chunk.toString('binary')));\n    if (self._parser) self._parser.write(chunk);\n  }\n\n  socket.on('error', onerror);\n\n  function onerror(err) {\n    clearTimeout(timer);\n    clearTimeout(self._keepalive);\n    self.emit('error', err);\n  }\n\n  socket.once('end', onend);\n\n  function onend() {\n    ondone();\n    self.emit('end');\n  }\n\n  socket.once('close', function (had_err) {\n    ondone();\n    self.emit('close', had_err);\n  });\n  var hasReset = false;\n\n  function ondone() {\n    if (!hasReset) {\n      hasReset = true;\n      clearTimeout(timer);\n\n      self._reset();\n    }\n  }\n\n  var timer = setTimeout(function () {\n    self.emit('error', new Error('Timeout while connecting to server'));\n    self._socket && self._socket.destroy();\n\n    self._reset();\n  }, this.options.connTimeout);\n\n  this._socket.connect(this.options.port, this.options.host);\n};\n\nFTP.prototype.end = function () {\n  if (this._queue.length) this._ending = true;else this._reset();\n};\n\nFTP.prototype.destroy = function () {\n  this._reset();\n}; // \"Standard\" (RFC 959) commands\n\n\nFTP.prototype.ascii = function (cb) {\n  return this._send('TYPE A', cb);\n};\n\nFTP.prototype.binary = function (cb) {\n  return this._send('TYPE I', cb);\n};\n\nFTP.prototype.abort = function (immediate, cb) {\n  if (typeof immediate === 'function') {\n    cb = immediate;\n    immediate = true;\n  }\n\n  if (immediate) this._send('ABOR', cb, true);else this._send('ABOR', cb);\n};\n\nFTP.prototype.cwd = function (path, cb, promote) {\n  this._send('CWD ' + path, function (err, text, code) {\n    if (err) return cb(err);\n    var m = RE_WD.exec(text);\n    cb(undefined, m ? m[1] : undefined);\n  }, promote);\n};\n\nFTP.prototype.delete = function (path, cb) {\n  this._send('DELE ' + path, cb);\n};\n\nFTP.prototype.site = function (cmd, cb) {\n  this._send('SITE ' + cmd, cb);\n};\n\nFTP.prototype.status = function (cb) {\n  this._send('STAT', cb);\n};\n\nFTP.prototype.rename = function (from, to, cb) {\n  var self = this;\n\n  this._send('RNFR ' + from, function (err) {\n    if (err) return cb(err);\n\n    self._send('RNTO ' + to, cb, true);\n  });\n};\n\nFTP.prototype.logout = function (cb) {\n  this._send('QUIT', cb);\n};\n\nFTP.prototype.listSafe = function (path, zcomp, cb) {\n  if (typeof path === 'string') {\n    var self = this; // store current path\n\n    this.pwd(function (err, origpath) {\n      if (err) return cb(err); // change to destination path\n\n      self.cwd(path, function (err) {\n        if (err) return cb(err); // get dir listing\n\n        self.list(zcomp || false, function (err, list) {\n          // change back to original path\n          if (err) return self.cwd(origpath, cb);\n          self.cwd(origpath, function (err) {\n            if (err) return cb(err);\n            cb(err, list);\n          });\n        });\n      });\n    });\n  } else this.list(path, zcomp, cb);\n};\n\nFTP.prototype.list = function (path, zcomp, cb) {\n  var self = this,\n      cmd;\n\n  if (typeof path === 'function') {\n    // list(function() {})\n    cb = path;\n    path = undefined;\n    cmd = 'LIST';\n    zcomp = false;\n  } else if (typeof path === 'boolean') {\n    // list(true, function() {})\n    cb = zcomp;\n    zcomp = path;\n    path = undefined;\n    cmd = 'LIST';\n  } else if (typeof zcomp === 'function') {\n    // list('/foo', function() {})\n    cb = zcomp;\n    cmd = 'LIST ' + path;\n    zcomp = false;\n  } else cmd = 'LIST ' + path;\n\n  this._pasv(function (err, sock) {\n    if (err) return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr,\n        done = false,\n        replies = 0,\n        entries,\n        buffer = '',\n        source = sock;\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n    }\n\n    source.on('data', function (chunk) {\n      buffer += chunk.toString('binary');\n    });\n    source.once('error', function (err) {\n      if (!sock.aborting) sockerr = err;\n    });\n    source.once('end', ondone);\n    source.once('close', ondone);\n\n    function ondone() {\n      done = true;\n      final();\n    }\n\n    function final() {\n      if (done && replies === 2) {\n        replies = 3;\n        if (sockerr) return cb(new Error('Unexpected data connection error: ' + sockerr));\n        if (sock.aborting) return cb(); // process received data\n\n        entries = buffer.split(RE_EOL);\n        entries.pop(); // ending EOL\n\n        var parsed = [];\n\n        for (var i = 0, len = entries.length; i < len; ++i) {\n          var parsedVal = Parser.parseListEntry(entries[i]);\n          if (parsedVal !== null) parsed.push(parsedVal);\n        }\n\n        if (zcomp) {\n          self._send('MODE S', function () {\n            cb(undefined, parsed);\n          }, true);\n        } else cb(undefined, parsed);\n      }\n    }\n\n    if (zcomp) {\n      self._send('MODE Z', function (err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n\n        sendList();\n      }, true);\n    } else sendList();\n\n    function sendList() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150 and then a final reply to indicate whether the\n      // transfer was actually a success or not\n      self._send(cmd, function (err, text, code) {\n        if (err) {\n          sock.destroy();\n\n          if (zcomp) {\n            self._send('MODE S', function () {\n              cb(err);\n            }, true);\n          } else cb(err);\n\n          return;\n        } // some servers may not open a data connection for empty directories\n\n\n        if (++replies === 1 && code === 226) {\n          replies = 2;\n          sock.destroy();\n          final();\n        } else if (replies === 2) final();\n      }, true);\n    }\n  });\n};\n\nFTP.prototype.get = function (path, zcomp, cb) {\n  var self = this;\n\n  if (typeof zcomp === 'function') {\n    cb = zcomp;\n    zcomp = false;\n  }\n\n  this._pasv(function (err, sock) {\n    if (err) return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    } // modify behavior of socket events so that we can emit 'error' once for\n    // either a TCP-level error OR an FTP-level error response that we get when\n    // the socket is closed (e.g. the server ran out of space).\n\n\n    var sockerr,\n        started = false,\n        lastreply = false,\n        done = false,\n        source = sock;\n\n    if (zcomp) {\n      source = zlib.createInflate();\n      sock.pipe(source);\n      sock._emit = sock.emit;\n\n      sock.emit = function (ev, arg1) {\n        if (ev === 'error') {\n          if (!sockerr) sockerr = arg1;\n          return;\n        }\n\n        sock._emit.apply(sock, Array.prototype.slice.call(arguments));\n      };\n    }\n\n    source._emit = source.emit;\n\n    source.emit = function (ev, arg1) {\n      if (ev === 'error') {\n        if (!sockerr) sockerr = arg1;\n        return;\n      } else if (ev === 'end' || ev === 'close') {\n        if (!done) {\n          done = true;\n          ondone();\n        }\n\n        return;\n      }\n\n      source._emit.apply(source, Array.prototype.slice.call(arguments));\n    };\n\n    function ondone() {\n      if (done && lastreply) {\n        self._send('MODE S', function () {\n          source._emit('end');\n\n          source._emit('close');\n        }, true);\n      }\n    }\n\n    sock.pause();\n\n    if (zcomp) {\n      self._send('MODE Z', function (err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        }\n\n        sendRetr();\n      }, true);\n    } else sendRetr();\n\n    function sendRetr() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150, then a final reply after the data connection closes\n      // to indicate whether the transfer was actually a success or not\n      self._send('RETR ' + path, function (err, text, code) {\n        if (sockerr || err) {\n          sock.destroy();\n\n          if (!started) {\n            if (zcomp) {\n              self._send('MODE S', function () {\n                cb(sockerr || err);\n              }, true);\n            } else cb(sockerr || err);\n          } else {\n            source._emit('error', sockerr || err);\n\n            source._emit('close', true);\n          }\n\n          return;\n        } // server returns 125 when data connection is already open; we treat it\n        // just like a 150\n\n\n        if (code === 150 || code === 125) {\n          started = true;\n          cb(undefined, source);\n          sock.resume();\n        } else {\n          lastreply = true;\n          ondone();\n        }\n      }, true);\n    }\n  });\n};\n\nFTP.prototype.put = function (input, path, zcomp, cb) {\n  this._store('STOR ' + path, input, zcomp, cb);\n};\n\nFTP.prototype.append = function (input, path, zcomp, cb) {\n  this._store('APPE ' + path, input, zcomp, cb);\n};\n\nFTP.prototype.pwd = function (cb) {\n  // PWD is optional\n  var self = this;\n\n  this._send('PWD', function (err, text, code) {\n    if (code === 502) {\n      return self.cwd('.', function (cwderr, cwd) {\n        if (cwderr) return cb(cwderr);\n        if (cwd === undefined) cb(err);else cb(undefined, cwd);\n      }, true);\n    } else if (err) return cb(err);\n\n    cb(undefined, RE_WD.exec(text)[1]);\n  });\n};\n\nFTP.prototype.cdup = function (cb) {\n  // CDUP is optional\n  var self = this;\n\n  this._send('CDUP', function (err, text, code) {\n    if (code === 502) self.cwd('..', cb, true);else cb(err);\n  });\n};\n\nFTP.prototype.mkdir = function (path, recursive, cb) {\n  // MKD is optional\n  if (typeof recursive === 'function') {\n    cb = recursive;\n    recursive = false;\n  }\n\n  if (!recursive) this._send('MKD ' + path, cb);else {\n    var self = this,\n        owd,\n        abs,\n        dirs,\n        dirslen,\n        i = -1,\n        searching = true;\n    abs = path[0] === '/';\n\n    var nextDir = function () {\n      if (++i === dirslen) {\n        // return to original working directory\n        return self._send('CWD ' + owd, cb, true);\n      }\n\n      if (searching) {\n        self._send('CWD ' + dirs[i], function (err, text, code) {\n          if (code === 550) {\n            searching = false;\n            --i;\n          } else if (err) {\n            // return to original working directory\n            return self._send('CWD ' + owd, function () {\n              cb(err);\n            }, true);\n          }\n\n          nextDir();\n        }, true);\n      } else {\n        self._send('MKD ' + dirs[i], function (err, text, code) {\n          if (err) {\n            // return to original working directory\n            return self._send('CWD ' + owd, function () {\n              cb(err);\n            }, true);\n          }\n\n          self._send('CWD ' + dirs[i], nextDir, true);\n        }, true);\n      }\n    };\n\n    this.pwd(function (err, cwd) {\n      if (err) return cb(err);\n      owd = cwd;\n      if (abs) path = path.substr(1);\n      if (path[path.length - 1] === '/') path = path.substring(0, path.length - 1);\n      dirs = path.split('/');\n      dirslen = dirs.length;\n      if (abs) self._send('CWD /', function (err) {\n        if (err) return cb(err);\n        nextDir();\n      }, true);else nextDir();\n    });\n  }\n};\n\nFTP.prototype.rmdir = function (path, recursive, cb) {\n  // RMD is optional\n  if (typeof recursive === 'function') {\n    cb = recursive;\n    recursive = false;\n  }\n\n  if (!recursive) {\n    return this._send('RMD ' + path, cb);\n  }\n\n  var self = this;\n  this.list(path, function (err, list) {\n    if (err) return cb(err);\n    var idx = 0; // this function will be called once per listing entry\n\n    var deleteNextEntry;\n\n    deleteNextEntry = function (err) {\n      if (err) return cb(err);\n\n      if (idx >= list.length) {\n        if (list[0] && list[0].name === path) {\n          return cb(null);\n        } else {\n          return self.rmdir(path, cb);\n        }\n      }\n\n      var entry = list[idx++]; // get the path to the file\n\n      var subpath = null;\n\n      if (entry.name[0] === '/') {\n        // this will be the case when you call deleteRecursively() and pass\n        // the path to a plain file\n        subpath = entry.name;\n      } else {\n        if (path[path.length - 1] == '/') {\n          subpath = path + entry.name;\n        } else {\n          subpath = path + '/' + entry.name;\n        }\n      } // delete the entry (recursively) according to its type\n\n\n      if (entry.type === 'd') {\n        if (entry.name === \".\" || entry.name === \"..\") {\n          return deleteNextEntry();\n        }\n\n        self.rmdir(subpath, true, deleteNextEntry);\n      } else {\n        self.delete(subpath, deleteNextEntry);\n      }\n    };\n\n    deleteNextEntry();\n  });\n};\n\nFTP.prototype.system = function (cb) {\n  // SYST is optional\n  this._send('SYST', function (err, text) {\n    if (err) return cb(err);\n    cb(undefined, RE_SYST.exec(text)[1]);\n  });\n}; // \"Extended\" (RFC 3659) commands\n\n\nFTP.prototype.size = function (path, cb) {\n  var self = this;\n\n  this._send('SIZE ' + path, function (err, text, code) {\n    if (code === 502) {\n      // Note: this may cause a problem as list() is _appended_ to the queue\n      return self.list(path, function (err, list) {\n        if (err) return cb(err);\n        if (list.length === 1) cb(undefined, list[0].size);else {\n          // path could have been a directory and we got a listing of its\n          // contents, but here we echo the behavior of the real SIZE and\n          // return 'File not found' for directories\n          cb(new Error('File not found'));\n        }\n      }, true);\n    } else if (err) return cb(err);\n\n    cb(undefined, parseInt(text, 10));\n  });\n};\n\nFTP.prototype.lastMod = function (path, cb) {\n  var self = this;\n\n  this._send('MDTM ' + path, function (err, text, code) {\n    if (code === 502) {\n      return self.list(path, function (err, list) {\n        if (err) return cb(err);\n        if (list.length === 1) cb(undefined, list[0].date);else cb(new Error('File not found'));\n      }, true);\n    } else if (err) return cb(err);\n\n    var val = XRegExp.exec(text, REX_TIMEVAL),\n        ret;\n    if (!val) return cb(new Error('Invalid date/time format from server'));\n    ret = new Date(val.year + '-' + val.month + '-' + val.date + 'T' + val.hour + ':' + val.minute + ':' + val.second);\n    cb(undefined, ret);\n  });\n};\n\nFTP.prototype.restart = function (offset, cb) {\n  this._send('REST ' + offset, cb);\n}; // Private/Internal methods\n\n\nFTP.prototype._pasv = function (cb) {\n  var self = this,\n      first = true,\n      ip,\n      port;\n\n  this._send('PASV', function reentry(err, text) {\n    if (err) return cb(err);\n    self._curReq = undefined;\n\n    if (first) {\n      var m = RE_PASV.exec(text);\n      if (!m) return cb(new Error('Unable to parse PASV server response'));\n      ip = m[1];\n      ip += '.';\n      ip += m[2];\n      ip += '.';\n      ip += m[3];\n      ip += '.';\n      ip += m[4];\n      port = parseInt(m[5], 10) * 256 + parseInt(m[6], 10);\n      first = false;\n    }\n\n    self._pasvConnect(ip, port, function (err, sock) {\n      if (err) {\n        // try the IP of the control connection if the server was somehow\n        // misconfigured and gave for example a LAN IP instead of WAN IP over\n        // the Internet\n        if (self._socket && ip !== self._socket.remoteAddress) {\n          ip = self._socket.remoteAddress;\n          return reentry();\n        } // automatically abort PASV mode\n\n\n        self._send('ABOR', function () {\n          cb(err);\n\n          self._send();\n        }, true);\n\n        return;\n      }\n\n      cb(undefined, sock);\n\n      self._send();\n    });\n  });\n};\n\nFTP.prototype._pasvConnect = function (ip, port, cb) {\n  var self = this,\n      socket = new Socket(),\n      sockerr,\n      timedOut = false,\n      timer = setTimeout(function () {\n    timedOut = true;\n    socket.destroy();\n    cb(new Error('Timed out while making data connection'));\n  }, this.options.pasvTimeout);\n  socket.setTimeout(0);\n  socket.once('connect', function () {\n    self._debug && self._debug('[connection] PASV socket connected');\n\n    if (self.options.secure === true) {\n      self.options.secureOptions.socket = socket;\n      self.options.secureOptions.session = self._socket.getSession(); //socket.removeAllListeners('error');\n\n      socket = tls.connect(self.options.secureOptions); //socket.once('error', onerror);\n\n      socket.setTimeout(0);\n    }\n\n    clearTimeout(timer);\n    self._pasvSocket = socket;\n    cb(undefined, socket);\n  });\n  socket.once('error', onerror);\n\n  function onerror(err) {\n    sockerr = err;\n  }\n\n  socket.once('end', function () {\n    clearTimeout(timer);\n  });\n  socket.once('close', function (had_err) {\n    clearTimeout(timer);\n\n    if (!self._pasvSocket && !timedOut) {\n      var errmsg = 'Unable to make data connection';\n\n      if (sockerr) {\n        errmsg += '( ' + sockerr + ')';\n        sockerr = undefined;\n      }\n\n      cb(new Error(errmsg));\n    }\n\n    self._pasvSocket = undefined;\n  });\n  socket.connect(port, ip);\n};\n\nFTP.prototype._store = function (cmd, input, zcomp, cb) {\n  var isBuffer = Buffer.isBuffer(input);\n  if (!isBuffer && input.pause !== undefined) input.pause();\n\n  if (typeof zcomp === 'function') {\n    cb = zcomp;\n    zcomp = false;\n  }\n\n  var self = this;\n\n  this._pasv(function (err, sock) {\n    if (err) return cb(err);\n\n    if (self._queue[0] && self._queue[0].cmd === 'ABOR') {\n      sock.destroy();\n      return cb();\n    }\n\n    var sockerr,\n        dest = sock;\n    sock.once('error', function (err) {\n      sockerr = err;\n    });\n\n    if (zcomp) {\n      self._send('MODE Z', function (err, text, code) {\n        if (err) {\n          sock.destroy();\n          return cb(makeError(code, 'Compression not supported'));\n        } // draft-preston-ftpext-deflate-04 says min of 8 should be supported\n\n\n        dest = zlib.createDeflate({\n          level: 8\n        });\n        dest.pipe(sock);\n        sendStore();\n      }, true);\n    } else sendStore();\n\n    function sendStore() {\n      // this callback will be executed multiple times, the first is when server\n      // replies with 150, then a final reply after the data connection closes\n      // to indicate whether the transfer was actually a success or not\n      self._send(cmd, function (err, text, code) {\n        if (sockerr || err) {\n          if (zcomp) {\n            self._send('MODE S', function () {\n              cb(sockerr || err);\n            }, true);\n          } else cb(sockerr || err);\n\n          return;\n        }\n\n        if (code === 150 || code === 125) {\n          if (isBuffer) dest.end(input);else if (typeof input === 'string') {\n            // check if input is a file path or just string data to store\n            fs.stat(input, function (err, stats) {\n              if (err) dest.end(input);else fs.createReadStream(input).pipe(dest);\n            });\n          } else {\n            input.pipe(dest);\n            input.resume();\n          }\n        } else {\n          if (zcomp) self._send('MODE S', cb, true);else cb();\n        }\n      }, true);\n    }\n  });\n};\n\nFTP.prototype._send = function (cmd, cb, promote) {\n  clearTimeout(this._keepalive);\n\n  if (cmd !== undefined) {\n    if (promote) this._queue.unshift({\n      cmd: cmd,\n      cb: cb\n    });else this._queue.push({\n      cmd: cmd,\n      cb: cb\n    });\n  }\n\n  var queueLen = this._queue.length;\n\n  if (!this._curReq && queueLen && this._socket && this._socket.readable) {\n    this._curReq = this._queue.shift();\n    if (this._curReq.cmd === 'ABOR' && this._pasvSocket) this._pasvSocket.aborting = true;\n    this._debug && this._debug('[connection] > ' + inspect(this._curReq.cmd));\n\n    this._socket.write(this._curReq.cmd + '\\r\\n');\n  } else if (!this._curReq && !queueLen && this._ending) this._reset();\n};\n\nFTP.prototype._reset = function () {\n  if (this._pasvSock && this._pasvSock.writable) this._pasvSock.end();\n  if (this._socket && this._socket.writable) this._socket.end();\n  this._socket = undefined;\n  this._pasvSock = undefined;\n  this._feat = undefined;\n  this._curReq = undefined;\n  this._secstate = undefined;\n  clearTimeout(this._keepalive);\n  this._keepalive = undefined;\n  this._queue = [];\n  this._ending = false;\n  this._parser = undefined;\n  this.options.host = this.options.port = this.options.user = this.options.password = this.options.secure = this.options.connTimeout = this.options.pasvTimeout = this.options.keepalive = this._debug = undefined;\n  this.connected = false;\n}; // Utility functions\n\n\nfunction makeError(code, text) {\n  var err = new Error(text);\n  err.code = code;\n  return err;\n}","map":null,"metadata":{},"sourceType":"script"}