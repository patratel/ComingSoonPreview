{"ast":null,"code":"var SmartBuffer = function () {\n  /**\n   * Constructor for SmartBuffer.\n   * @param arg1 {Buffer || Number || String} Buffer to read from, or expected size to write to, or encoding to use.\n   * @param arg2 {String} Encoding to use for writing and reading strings. Defaults to utf8. If encoding is given in arg1, this is ignored.\n   * @constructor\n   *\n   * There are a few ways to construct a SmartBuffer:\n   *\n   * SmartBuffer() - Defaults to utf8, 4096 pre-set internal Buffer length.\n   * SmartBuffer(size) - Defaults to utf8, sets internal Buffer length to the size given.\n   * SmartBuffer(encoding) - Sets the given encoding, defaults to 4096 pre-set internal Buffer length.\n   * SmartBuffer(Buffer) - Defaults to utf8, sets the internal Buffer to the given buffer (same memory).\n   * SmartBuffer(Buffer, encoding) - Sets the given encoding, sets the internal Buffer to the given buffer (same memory).\n   *\n   */\n  function SmartBuffer(arg1, arg2) {\n    var type;\n\n    switch (type = typeof arg1) {\n      case 'number':\n        if (isFinite(arg1) && arg1 > 0) {\n          this.buff = new Buffer(Math.ceil(arg1));\n          this.length = 0;\n        } else {\n          throw new Error('When specifying a size, it must be a valid number above zero.');\n        }\n\n        break;\n\n      case 'string':\n        if (Buffer.isEncoding(arg1)) {\n          this.buff = new Buffer(4096);\n          this.length = 0;\n          this.encoding = arg1;\n        } else {\n          throw new Error('Invalid Encoding');\n        }\n\n        break;\n\n      case 'object':\n        if (Buffer.isBuffer(arg1)) {\n          this.buff = arg1;\n          this.length = arg1.length;\n        } else {\n          throw new TypeError('First argument must be a Buffer, Number representing the size, or a String representing the encoding.');\n        }\n\n        break;\n\n      default:\n        this.buff = new Buffer(4096);\n        this.length = 0;\n        break;\n    }\n\n    if (typeof this.encoding === 'undefined') {\n      if (typeof arg2 === 'string') {\n        if (Buffer.isEncoding(arg2)) {\n          this.encoding = arg2;\n        } else {\n          throw new Error('Invalid Encoding');\n        }\n      }\n    }\n\n    this._readOffset = 0;\n    this._writeOffset = 0;\n  }\n\n  SmartBuffer.prototype._ensureWritable = function (len, offset) {\n    this._ensureCapacity(this.length + len + (typeof offset === 'number' ? offset : 0));\n\n    if (typeof offset === 'number') {\n      this.buff.copy(this.buff, offset + len, offset, this.buff.length);\n    }\n\n    this.length = Math.max(this.length + len, (typeof offset === 'number' ? offset : 0) + len);\n  };\n\n  SmartBuffer.prototype._ensureCapacity = function (minlen) {\n    var oldlen = this.buff.length;\n\n    if (minlen > oldlen) {\n      var data = this.buff;\n      var newlen = oldlen * 3 / 2 + 1;\n      if (newlen < minlen) newlen = minlen;\n      this.buff = new Buffer(newlen);\n      data.copy(this.buff, 0, 0, oldlen);\n    }\n  };\n\n  var makeReader = function (func, size) {\n    return function () {\n      var ret = func.call(this.buff, this._readOffset);\n      this._readOffset += size;\n      return ret;\n    };\n  };\n\n  var makeWriter = function (func, size) {\n    return function (value, offset) {\n      this._ensureWritable(size, offset);\n\n      func.call(this.buff, value, typeof offset === 'number' ? offset : this._writeOffset);\n      this._writeOffset += size;\n      return this;\n    };\n  };\n  /*\n   Read Operations\n   */\n\n\n  SmartBuffer.prototype.readInt8 = makeReader(Buffer.prototype.readInt8, 1);\n  SmartBuffer.prototype.readInt16BE = makeReader(Buffer.prototype.readInt16BE, 2);\n  SmartBuffer.prototype.readInt16LE = makeReader(Buffer.prototype.readInt16LE, 2);\n  SmartBuffer.prototype.readInt32BE = makeReader(Buffer.prototype.readInt32BE, 4);\n  SmartBuffer.prototype.readInt32LE = makeReader(Buffer.prototype.readInt32LE, 4);\n  SmartBuffer.prototype.readUInt8 = makeReader(Buffer.prototype.readUInt8, 1);\n  SmartBuffer.prototype.readUInt16BE = makeReader(Buffer.prototype.readUInt16BE, 2);\n  SmartBuffer.prototype.readUInt16LE = makeReader(Buffer.prototype.readUInt16LE, 2);\n  SmartBuffer.prototype.readUInt32BE = makeReader(Buffer.prototype.readUInt32BE, 4);\n  SmartBuffer.prototype.readUInt32LE = makeReader(Buffer.prototype.readUInt32LE, 4);\n  SmartBuffer.prototype.readFloatBE = makeReader(Buffer.prototype.readFloatBE, 4);\n  SmartBuffer.prototype.readFloatLE = makeReader(Buffer.prototype.readFloatLE, 4);\n  SmartBuffer.prototype.readDoubleBE = makeReader(Buffer.prototype.readDoubleBE, 8);\n  SmartBuffer.prototype.readDoubleLE = makeReader(Buffer.prototype.readDoubleLE, 8);\n  /**\n   * Reads a string of the given length.\n   * @param length {Number} The length of the string to read. (Defaults to the length of the remaining data)\n   * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or utf8)\n   * @returns {string} The string.\n   */\n\n  SmartBuffer.prototype.readString = function (length, encoding) {\n    var len = Math.min(length, this.length - this._readOffset) || this.length - this._readOffset;\n\n    var ret = this.buff.slice(this._readOffset, this._readOffset + len).toString(encoding || this.encoding);\n    this._readOffset += len;\n    return ret;\n  };\n  /**\n   * Reads a null terminated string from the underlying buffer.\n   * @param encoding {String} Encoding to use. Defaults to encoding set in constructor, or utf8.\n   * @returns {string}\n   */\n\n\n  SmartBuffer.prototype.readStringNT = function (encoding) {\n    var nullpos = this.length;\n\n    for (var i = this._readOffset; i < this.length; i++) {\n      if (this.buff[i] == 0x00) {\n        nullpos = i;\n        break;\n      }\n    }\n\n    var result = this.buff.slice(this._readOffset, nullpos);\n    this._readOffset = nullpos + 1;\n    return result.toString(encoding || this.encoding);\n  };\n  /**\n   * Reads a specified number of bytes.\n   * @param len {Number} Numbers of bytes to read. (Defaults to the remaining data length)\n   * @returns {Buffer} Buffer containing the read bytes.\n   */\n\n\n  SmartBuffer.prototype.readBuffer = function (len) {\n    var endpoint = Math.min(this.length, this._readOffset + (typeof len === 'number' ? len : this.length));\n    var ret = this.buff.slice(this._readOffset, endpoint);\n    this._readOffset = endpoint;\n    return ret;\n  };\n  /**\n   * Reads a null terminated sequence of bytes from the underlying buffer.\n   * @returns {Buffer} Buffer containing the read bytes.\n   */\n\n\n  SmartBuffer.prototype.readBufferNT = function () {\n    var nullpos = this.length;\n\n    for (var i = this._readOffset; i < this.length; i++) {\n      if (this.buff[i] == 0x00) {\n        nullpos = i;\n        break;\n      }\n    }\n\n    var ret = this.buff.slice(this._readOffset, nullpos);\n    this._readOffset = nullpos + 1;\n    return ret;\n  };\n  /*\n   Write Operations\n   */\n\n\n  SmartBuffer.prototype.writeInt8 = makeWriter(Buffer.prototype.writeInt8, 1);\n  SmartBuffer.prototype.writeInt16BE = makeWriter(Buffer.prototype.writeInt16BE, 2);\n  SmartBuffer.prototype.writeInt16LE = makeWriter(Buffer.prototype.writeInt16LE, 2);\n  SmartBuffer.prototype.writeInt32BE = makeWriter(Buffer.prototype.writeInt32BE, 4);\n  SmartBuffer.prototype.writeInt32LE = makeWriter(Buffer.prototype.writeInt32LE, 4);\n  SmartBuffer.prototype.writeUInt8 = makeWriter(Buffer.prototype.writeUInt8, 1);\n  SmartBuffer.prototype.writeUInt16BE = makeWriter(Buffer.prototype.writeUInt16BE, 2);\n  SmartBuffer.prototype.writeUInt16LE = makeWriter(Buffer.prototype.writeUInt16LE, 2);\n  SmartBuffer.prototype.writeUInt32BE = makeWriter(Buffer.prototype.writeUInt32BE, 4);\n  SmartBuffer.prototype.writeUInt32LE = makeWriter(Buffer.prototype.writeUInt32LE, 4);\n  SmartBuffer.prototype.writeFloatBE = makeWriter(Buffer.prototype.writeFloatBE, 4);\n  SmartBuffer.prototype.writeFloatLE = makeWriter(Buffer.prototype.writeFloatLE, 4);\n  SmartBuffer.prototype.writeDoubleBE = makeWriter(Buffer.prototype.writeDoubleBE, 8);\n  SmartBuffer.prototype.writeDoubleLE = makeWriter(Buffer.prototype.writeDoubleLE, 8);\n  /**\n   * Writes a string to the underlying buffer.\n   * @param value {String} The string to write.\n   * @param offset {Number} The offset to write the string to. (Encoding can also be set here in place of offset)\n   * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or to utf8)\n   * @returns {*}\n   */\n\n  SmartBuffer.prototype.writeString = function (value, offset, encoding) {\n    var len,\n        _offset,\n        type = typeof offset;\n\n    if (type === 'number') {\n      _offset = offset;\n    } else if (type === 'string') {\n      encoding = offset;\n      offset = this._writeOffset;\n    } else {\n      encoding = undefined;\n      offset = this._writeOffset;\n    }\n\n    len = Buffer.byteLength(value, encoding || this.encoding);\n\n    this._ensureWritable(len, _offset);\n\n    this.buff.write(value, offset, len, encoding || this.encoding);\n    this._writeOffset += len;\n    return this;\n  };\n  /**\n   * Writes a null terminated string to the underlying buffer.\n   * @param value {String} The string to write.\n   * @param offset {Number} The offset to write the string to. (Encoding can also be set here in place of offset)\n   * @param encoding {String} The encoding to use. (Defaults to encoding set in constructor, or to utf8)\n   * @returns {*}\n   */\n\n\n  SmartBuffer.prototype.writeStringNT = function (value, offset, encoding) {\n    this.writeString(value, offset, encoding);\n    this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n    return this;\n  };\n  /**\n   * Writes a Buffer to the underlying buffer.\n   * @param value {Buffer} The buffer to write.\n   * @param offset {Number} The offset to write the Buffer to.\n   * @returns {*}\n   */\n\n\n  SmartBuffer.prototype.writeBuffer = function (value, offset) {\n    var len = value.length;\n\n    this._ensureWritable(len, offset);\n\n    value.copy(this.buff, typeof offset === 'number' ? offset : this._writeOffset);\n    this._writeOffset += len;\n    return this;\n  };\n  /**\n   * Writes a null terminated Buffer to the underlying buffer.\n   * @param value {Buffer} The buffer to write.\n   * @param offset {Number} The offset to write the Buffer to.\n   * @returns {*}\n   */\n\n\n  SmartBuffer.prototype.writeBufferNT = function (value, offset) {\n    this.writeBuffer(value, offset);\n    this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n    return this;\n  };\n  /**\n   * Resets the Endless Buffer.\n   */\n\n\n  SmartBuffer.prototype.clear = function () {\n    this._writeOffset = 0;\n    this._readOffset = 0;\n    this.length = 0;\n  };\n  /**\n   * Gets the remaining number of bytes to be read from the existing Buffer.\n   * @returns {number} The number of bytes remaining.\n   */\n\n\n  SmartBuffer.prototype.remaining = function () {\n    return this.length - this._readOffset;\n  };\n  /**\n   * Skips the read position forward by the amount of given.\n   * @param amount {Number} The amount of bytes to skip forward.\n   */\n\n\n  SmartBuffer.prototype.skip = function (amount) {\n    if (this._readOffset + amount > this.length) throw new Error('Target position is beyond the bounds of the data.');\n    this._readOffset += amount;\n  };\n  /**\n   * Rewinds the read position backward by the amount given.\n   * @param amount {Number} The amount of bytes to reverse backward.\n   */\n\n\n  SmartBuffer.prototype.rewind = function (amount) {\n    if (this._readOffset - amount < 0) throw new Error('Target position is beyond the bounds of the data.');\n    this._readOffset -= amount;\n  };\n  /**\n   * Skips the read position to the given position.\n   * @param position {Number} The position to skip to.\n   */\n\n\n  SmartBuffer.prototype.skipTo = function (position) {\n    if (position < 0 || position > this.length) throw new Error('Target position is beyond the bounds of the data.');\n    this._readOffset = position;\n  };\n  /**\n   * Gets the underlying Buffer.\n   * @returns {*}\n   */\n\n\n  SmartBuffer.prototype.toBuffer = function () {\n    return this.buff.slice(0, this.length);\n  };\n  /**\n   * Gets a string representation of the underlying Buffer.\n   * @param encoding {String} Encoding to use. (Defaults to encoding set in constructor, or utf8.)\n   * @returns {*}\n   */\n\n\n  SmartBuffer.prototype.toString = function (encoding) {\n    return this.buff.toString(encoding || this.encoding, 0, this.length);\n  };\n  /**\n   * Destroys the underlying Buffer, and resets the SmartBuffer.\n   */\n\n\n  SmartBuffer.prototype.destroy = function () {\n    delete this.buff;\n    this.clear();\n  };\n\n  return SmartBuffer;\n}();\n\nmodule.exports = SmartBuffer;","map":null,"metadata":{},"sourceType":"script"}