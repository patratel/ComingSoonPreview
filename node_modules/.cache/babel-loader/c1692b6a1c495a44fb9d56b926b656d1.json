{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nvar path_1 = __importDefault(require(\"./path\"));\n\nvar scope_1 = __importDefault(require(\"./scope\"));\n\nfunction nodePathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var n = types.namedTypes;\n  var b = types.builders;\n  var isNumber = types.builtInTypes.number;\n  var isArray = types.builtInTypes.array;\n  var Path = fork.use(path_1.default);\n  var Scope = fork.use(scope_1.default);\n\n  var NodePath = function NodePath(value, parentPath, name) {\n    if (!(this instanceof NodePath)) {\n      throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n\n    Path.call(this, value, parentPath, name);\n  };\n\n  var NPp = NodePath.prototype = Object.create(Path.prototype, {\n    constructor: {\n      value: NodePath,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(NPp, {\n    node: {\n      get: function () {\n        Object.defineProperty(this, \"node\", {\n          configurable: true,\n          value: this._computeNode()\n        });\n        return this.node;\n      }\n    },\n    parent: {\n      get: function () {\n        Object.defineProperty(this, \"parent\", {\n          configurable: true,\n          value: this._computeParent()\n        });\n        return this.parent;\n      }\n    },\n    scope: {\n      get: function () {\n        Object.defineProperty(this, \"scope\", {\n          configurable: true,\n          value: this._computeScope()\n        });\n        return this.scope;\n      }\n    }\n  });\n\n  NPp.replace = function () {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path.prototype.replace.apply(this, arguments);\n  };\n\n  NPp.prune = function () {\n    var remainingNodePath = this.parent;\n    this.replace();\n    return cleanUpNodesAfterPrune(remainingNodePath);\n  }; // The value of the first ancestor Path whose value is a Node.\n\n\n  NPp._computeNode = function () {\n    var value = this.value;\n\n    if (n.Node.check(value)) {\n      return value;\n    }\n\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n  }; // The first ancestor Path whose value is a Node distinct from this.node.\n\n\n  NPp._computeParent = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n\n    if (!n.Node.check(value)) {\n      while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n      }\n\n      if (pp) {\n        pp = pp.parentPath;\n      }\n    }\n\n    while (pp && !n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n    }\n\n    return pp || null;\n  }; // The closest enclosing scope that governs this node.\n\n\n  NPp._computeScope = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n\n    if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n      scope = new Scope(this, scope);\n    }\n\n    return scope || null;\n  };\n\n  NPp.getValueProperty = function (name) {\n    return types.getFieldValue(this.value, name);\n  };\n  /**\n   * Determine whether this.node needs to be wrapped in parentheses in order\n   * for a parser to reproduce the same local AST structure.\n   *\n   * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n   * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n   * parse differently.\n   *\n   * If assumeExpressionContext === true, we don't worry about edge cases\n   * like an anonymous FunctionExpression appearing lexically first in its\n   * enclosing statement and thus needing parentheses to avoid being parsed\n   * as a FunctionDeclaration with a missing name.\n   */\n\n\n  NPp.needsParens = function (assumeExpressionContext) {\n    var pp = this.parentPath;\n\n    if (!pp) {\n      return false;\n    }\n\n    var node = this.value; // Only expressions need parentheses.\n\n    if (!n.Expression.check(node)) {\n      return false;\n    } // Identifiers never need parentheses.\n\n\n    if (node.type === \"Identifier\") {\n      return false;\n    }\n\n    while (!n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n\n      if (!pp) {\n        return false;\n      }\n    }\n\n    var parent = pp.value;\n\n    switch (node.type) {\n      case \"UnaryExpression\":\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && this.name === \"object\" && parent.object === node;\n\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n            return true;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            {\n              var n_1 = node;\n              var po = parent.operator;\n              var pp_1 = PRECEDENCE[po];\n              var no = n_1.operator;\n              var np = PRECEDENCE[no];\n\n              if (pp_1 > np) {\n                return true;\n              }\n\n              if (pp_1 === np && this.name === \"right\") {\n                if (parent.right !== n_1) {\n                  throw new Error(\"Nodes must be equal\");\n                }\n\n                return true;\n              }\n            }\n\n          default:\n            return false;\n        }\n\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n\n          case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n\n          default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n\n      case \"YieldExpression\":\n        switch (parent.type) {\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"CallExpression\":\n          case \"MemberExpression\":\n          case \"NewExpression\":\n          case \"ConditionalExpression\":\n          case \"YieldExpression\":\n            return true;\n\n          default:\n            return false;\n        }\n\n      case \"Literal\":\n        return parent.type === \"MemberExpression\" && isNumber.check(node.value) && this.name === \"object\" && parent.object === node;\n\n      case \"AssignmentExpression\":\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            return true;\n\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n\n          case \"ConditionalExpression\":\n            return this.name === \"test\" && parent.test === node;\n\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n\n          default:\n            return false;\n        }\n\n      default:\n        if (parent.type === \"NewExpression\" && this.name === \"callee\" && parent.callee === node) {\n          return containsCallExpression(node);\n        }\n\n    }\n\n    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;\n    return false;\n  };\n\n  function isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n  } // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n\n\n  function isUnaryLike(node) {\n    return n.UnaryExpression.check(node) // I considered making SpreadElement and SpreadProperty subtypes\n    // of UnaryExpression, but they're not really Expression nodes.\n    || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n  }\n\n  var PRECEDENCE = {};\n  [[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"]].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n\n  function containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n      return true;\n    }\n\n    if (isArray.check(node)) {\n      return node.some(containsCallExpression);\n    }\n\n    if (n.Node.check(node)) {\n      return types.someField(node, function (_name, child) {\n        return containsCallExpression(child);\n      });\n    }\n\n    return false;\n  }\n\n  NPp.canBeFirstInStatement = function () {\n    var node = this.node;\n    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n  };\n\n  NPp.firstInStatement = function () {\n    return firstInStatement(this);\n  };\n\n  function firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n      node = path.node;\n      parent = path.parent.node;\n\n      if (n.BlockStatement.check(parent) && path.parent.name === \"body\" && path.name === 0) {\n        if (parent.body[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.ExpressionStatement.check(parent) && path.name === \"expression\") {\n        if (parent.expression !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        return true;\n      }\n\n      if (n.SequenceExpression.check(parent) && path.parent.name === \"expressions\" && path.name === 0) {\n        if (parent.expressions[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.CallExpression.check(parent) && path.name === \"callee\") {\n        if (parent.callee !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.MemberExpression.check(parent) && path.name === \"object\") {\n        if (parent.object !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.ConditionalExpression.check(parent) && path.name === \"test\") {\n        if (parent.test !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (isBinary(parent) && path.name === \"left\") {\n        if (parent.left !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === \"argument\") {\n        if (parent.argument !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n\n        continue;\n      }\n\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n   */\n\n\n  function cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n      var declarations = remainingNodePath.get('declarations').value;\n\n      if (!declarations || declarations.length === 0) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n      if (!remainingNodePath.get('expression').value) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n      cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n\n    return remainingNodePath;\n  }\n\n  function cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get('test').value;\n    var alternate = ifStatement.get('alternate').value;\n    var consequent = ifStatement.get('consequent').value;\n\n    if (!consequent && !alternate) {\n      var testExpressionStatement = b.expressionStatement(testExpression);\n      ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n      var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n\n      if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n        negatedTestExpression = testExpression.argument;\n      }\n\n      ifStatement.get(\"test\").replace(negatedTestExpression);\n      ifStatement.get(\"consequent\").replace(alternate);\n      ifStatement.get(\"alternate\").replace();\n    }\n  }\n\n  return NodePath;\n}\n\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}