{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar babel_core_1 = __importDefault(require(\"./babel-core\"));\n\nvar type_annotations_1 = __importDefault(require(\"./type-annotations\"));\n\nvar types_1 = __importDefault(require(\"../lib/types\"));\n\nvar shared_1 = __importDefault(require(\"../lib/shared\"));\n\nfunction default_1(fork) {\n  // Since TypeScript is parsed by Babylon, include the core Babylon types\n  // but omit the Flow-related types.\n  fork.use(babel_core_1.default);\n  fork.use(type_annotations_1.default);\n  var types = fork.use(types_1.default);\n  var n = types.namedTypes;\n  var def = types.Type.def;\n  var or = types.Type.or;\n  var defaults = fork.use(shared_1.default).defaults;\n  var StringLiteral = types.Type.from(function (value, deep) {\n    if (n.StringLiteral && n.StringLiteral.check(value, deep)) {\n      return true;\n    }\n\n    if (n.Literal && n.Literal.check(value, deep) && typeof value.value === \"string\") {\n      return true;\n    }\n\n    return false;\n  }, \"StringLiteral\");\n  def(\"TSType\").bases(\"Node\");\n  var TSEntityName = or(def(\"Identifier\"), def(\"TSQualifiedName\"));\n  def(\"TSTypeReference\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"typeName\", \"typeParameters\").field(\"typeName\", TSEntityName); // An abstract (non-buildable) base type that provide a commonly-needed\n  // optional .typeParameters field.\n\n  def(\"TSHasOptionalTypeParameterInstantiation\").field(\"typeParameters\", or(def(\"TSTypeParameterInstantiation\"), null), defaults[\"null\"]); // An abstract (non-buildable) base type that provide a commonly-needed\n  // optional .typeParameters field.\n\n  def(\"TSHasOptionalTypeParameters\").field(\"typeParameters\", or(def(\"TSTypeParameterDeclaration\"), null, void 0), defaults[\"null\"]); // An abstract (non-buildable) base type that provide a commonly-needed\n  // optional .typeAnnotation field.\n\n  def(\"TSHasOptionalTypeAnnotation\").field(\"typeAnnotation\", or(def(\"TSTypeAnnotation\"), null), defaults[\"null\"]);\n  def(\"TSQualifiedName\").bases(\"Node\").build(\"left\", \"right\").field(\"left\", TSEntityName).field(\"right\", TSEntityName);\n  def(\"TSAsExpression\").bases(\"Expression\", \"Pattern\").build(\"expression\", \"typeAnnotation\").field(\"expression\", def(\"Expression\")).field(\"typeAnnotation\", def(\"TSType\")).field(\"extra\", or({\n    parenthesized: Boolean\n  }, null), defaults[\"null\"]);\n  def(\"TSNonNullExpression\").bases(\"Expression\", \"Pattern\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  [\"TSAnyKeyword\", \"TSBigIntKeyword\", \"TSBooleanKeyword\", \"TSNeverKeyword\", \"TSNullKeyword\", \"TSNumberKeyword\", \"TSObjectKeyword\", \"TSStringKeyword\", \"TSSymbolKeyword\", \"TSUndefinedKeyword\", \"TSUnknownKeyword\", \"TSVoidKeyword\", \"TSThisType\"].forEach(function (keywordType) {\n    def(keywordType).bases(\"TSType\").build();\n  });\n  def(\"TSArrayType\").bases(\"TSType\").build(\"elementType\").field(\"elementType\", def(\"TSType\"));\n  def(\"TSLiteralType\").bases(\"TSType\").build(\"literal\").field(\"literal\", or(def(\"NumericLiteral\"), def(\"StringLiteral\"), def(\"BooleanLiteral\"), def(\"TemplateLiteral\"), def(\"UnaryExpression\")));\n  [\"TSUnionType\", \"TSIntersectionType\"].forEach(function (typeName) {\n    def(typeName).bases(\"TSType\").build(\"types\").field(\"types\", [def(\"TSType\")]);\n  });\n  def(\"TSConditionalType\").bases(\"TSType\").build(\"checkType\", \"extendsType\", \"trueType\", \"falseType\").field(\"checkType\", def(\"TSType\")).field(\"extendsType\", def(\"TSType\")).field(\"trueType\", def(\"TSType\")).field(\"falseType\", def(\"TSType\"));\n  def(\"TSInferType\").bases(\"TSType\").build(\"typeParameter\").field(\"typeParameter\", def(\"TSTypeParameter\"));\n  def(\"TSParenthesizedType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  var ParametersType = [or(def(\"Identifier\"), def(\"RestElement\"), def(\"ArrayPattern\"), def(\"ObjectPattern\"))];\n  [\"TSFunctionType\", \"TSConstructorType\"].forEach(function (typeName) {\n    def(typeName).bases(\"TSType\", \"TSHasOptionalTypeParameters\", \"TSHasOptionalTypeAnnotation\").build(\"parameters\").field(\"parameters\", ParametersType);\n  });\n  def(\"TSDeclareFunction\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"params\", \"returnType\").field(\"declare\", Boolean, defaults[\"false\"]).field(\"async\", Boolean, defaults[\"false\"]).field(\"generator\", Boolean, defaults[\"false\"]).field(\"id\", or(def(\"Identifier\"), null), defaults[\"null\"]).field(\"params\", [def(\"Pattern\")]) // tSFunctionTypeAnnotationCommon\n  .field(\"returnType\", or(def(\"TSTypeAnnotation\"), def(\"Noop\"), // Still used?\n  null), defaults[\"null\"]);\n  def(\"TSDeclareMethod\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"key\", \"params\", \"returnType\").field(\"async\", Boolean, defaults[\"false\"]).field(\"generator\", Boolean, defaults[\"false\"]).field(\"params\", [def(\"Pattern\")]) // classMethodOrPropertyCommon\n  .field(\"abstract\", Boolean, defaults[\"false\"]).field(\"accessibility\", or(\"public\", \"private\", \"protected\", void 0), defaults[\"undefined\"]).field(\"static\", Boolean, defaults[\"false\"]).field(\"computed\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"key\", or(def(\"Identifier\"), def(\"StringLiteral\"), def(\"NumericLiteral\"), // Only allowed if .computed is true.\n  def(\"Expression\"))) // classMethodOrDeclareMethodCommon\n  .field(\"kind\", or(\"get\", \"set\", \"method\", \"constructor\"), function getDefault() {\n    return \"method\";\n  }).field(\"access\", // Not \"accessibility\"?\n  or(\"public\", \"private\", \"protected\", void 0), defaults[\"undefined\"]).field(\"decorators\", or([def(\"Decorator\")], null), defaults[\"null\"]) // tSFunctionTypeAnnotationCommon\n  .field(\"returnType\", or(def(\"TSTypeAnnotation\"), def(\"Noop\"), // Still used?\n  null), defaults[\"null\"]);\n  def(\"TSMappedType\").bases(\"TSType\").build(\"typeParameter\", \"typeAnnotation\").field(\"readonly\", or(Boolean, \"+\", \"-\"), defaults[\"false\"]).field(\"typeParameter\", def(\"TSTypeParameter\")).field(\"optional\", or(Boolean, \"+\", \"-\"), defaults[\"false\"]).field(\"typeAnnotation\", or(def(\"TSType\"), null), defaults[\"null\"]);\n  def(\"TSTupleType\").bases(\"TSType\").build(\"elementTypes\").field(\"elementTypes\", [def(\"TSType\")]);\n  def(\"TSRestType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSOptionalType\").bases(\"TSType\").build(\"typeAnnotation\").field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSIndexedAccessType\").bases(\"TSType\").build(\"objectType\", \"indexType\").field(\"objectType\", def(\"TSType\")).field(\"indexType\", def(\"TSType\"));\n  def(\"TSTypeOperator\").bases(\"TSType\").build(\"operator\").field(\"operator\", String).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSTypeAnnotation\").bases(\"Node\").build(\"typeAnnotation\").field(\"typeAnnotation\", or(def(\"TSType\"), def(\"TSTypeAnnotation\")));\n  def(\"TSIndexSignature\").bases(\"Declaration\", \"TSHasOptionalTypeAnnotation\").build(\"parameters\", \"typeAnnotation\").field(\"parameters\", [def(\"Identifier\")]) // Length === 1\n  .field(\"readonly\", Boolean, defaults[\"false\"]);\n  def(\"TSPropertySignature\").bases(\"Declaration\", \"TSHasOptionalTypeAnnotation\").build(\"key\", \"typeAnnotation\", \"optional\").field(\"key\", def(\"Expression\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"readonly\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"initializer\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"TSMethodSignature\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\", \"TSHasOptionalTypeAnnotation\").build(\"key\", \"parameters\", \"typeAnnotation\").field(\"key\", def(\"Expression\")).field(\"computed\", Boolean, defaults[\"false\"]).field(\"optional\", Boolean, defaults[\"false\"]).field(\"parameters\", ParametersType);\n  def(\"TSTypePredicate\").bases(\"TSTypeAnnotation\").build(\"parameterName\", \"typeAnnotation\").field(\"parameterName\", or(def(\"Identifier\"), def(\"TSThisType\"))).field(\"typeAnnotation\", def(\"TSTypeAnnotation\"));\n  [\"TSCallSignatureDeclaration\", \"TSConstructSignatureDeclaration\"].forEach(function (typeName) {\n    def(typeName).bases(\"Declaration\", \"TSHasOptionalTypeParameters\", \"TSHasOptionalTypeAnnotation\").build(\"parameters\", \"typeAnnotation\").field(\"parameters\", ParametersType);\n  });\n  def(\"TSEnumMember\").bases(\"Node\").build(\"id\", \"initializer\").field(\"id\", or(def(\"Identifier\"), StringLiteral)).field(\"initializer\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"TSTypeQuery\").bases(\"TSType\").build(\"exprName\").field(\"exprName\", or(TSEntityName, def(\"TSImportType\"))); // Inferred from Babylon's tsParseTypeMember method.\n\n  var TSTypeMember = or(def(\"TSCallSignatureDeclaration\"), def(\"TSConstructSignatureDeclaration\"), def(\"TSIndexSignature\"), def(\"TSMethodSignature\"), def(\"TSPropertySignature\"));\n  def(\"TSTypeLiteral\").bases(\"TSType\").build(\"members\").field(\"members\", [TSTypeMember]);\n  def(\"TSTypeParameter\").bases(\"Identifier\").build(\"name\", \"constraint\", \"default\").field(\"name\", String).field(\"constraint\", or(def(\"TSType\"), void 0), defaults[\"undefined\"]).field(\"default\", or(def(\"TSType\"), void 0), defaults[\"undefined\"]);\n  def(\"TSTypeAssertion\").bases(\"Expression\", \"Pattern\").build(\"typeAnnotation\", \"expression\").field(\"typeAnnotation\", def(\"TSType\")).field(\"expression\", def(\"Expression\")).field(\"extra\", or({\n    parenthesized: Boolean\n  }, null), defaults[\"null\"]);\n  def(\"TSTypeParameterDeclaration\").bases(\"Declaration\").build(\"params\").field(\"params\", [def(\"TSTypeParameter\")]);\n  def(\"TSTypeParameterInstantiation\").bases(\"Node\").build(\"params\").field(\"params\", [def(\"TSType\")]);\n  def(\"TSEnumDeclaration\").bases(\"Declaration\").build(\"id\", \"members\").field(\"id\", def(\"Identifier\")).field(\"const\", Boolean, defaults[\"false\"]).field(\"declare\", Boolean, defaults[\"false\"]).field(\"members\", [def(\"TSEnumMember\")]).field(\"initializer\", or(def(\"Expression\"), null), defaults[\"null\"]);\n  def(\"TSTypeAliasDeclaration\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"typeAnnotation\").field(\"id\", def(\"Identifier\")).field(\"declare\", Boolean, defaults[\"false\"]).field(\"typeAnnotation\", def(\"TSType\"));\n  def(\"TSModuleBlock\").bases(\"Node\").build(\"body\").field(\"body\", [def(\"Statement\")]);\n  def(\"TSModuleDeclaration\").bases(\"Declaration\").build(\"id\", \"body\").field(\"id\", or(StringLiteral, TSEntityName)).field(\"declare\", Boolean, defaults[\"false\"]).field(\"global\", Boolean, defaults[\"false\"]).field(\"body\", or(def(\"TSModuleBlock\"), def(\"TSModuleDeclaration\"), null), defaults[\"null\"]);\n  def(\"TSImportType\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"argument\", \"qualifier\", \"typeParameters\").field(\"argument\", StringLiteral).field(\"qualifier\", or(TSEntityName, void 0), defaults[\"undefined\"]);\n  def(\"TSImportEqualsDeclaration\").bases(\"Declaration\").build(\"id\", \"moduleReference\").field(\"id\", def(\"Identifier\")).field(\"isExport\", Boolean, defaults[\"false\"]).field(\"moduleReference\", or(TSEntityName, def(\"TSExternalModuleReference\")));\n  def(\"TSExternalModuleReference\").bases(\"Declaration\").build(\"expression\").field(\"expression\", StringLiteral);\n  def(\"TSExportAssignment\").bases(\"Statement\").build(\"expression\").field(\"expression\", def(\"Expression\"));\n  def(\"TSNamespaceExportDeclaration\").bases(\"Declaration\").build(\"id\").field(\"id\", def(\"Identifier\"));\n  def(\"TSInterfaceBody\").bases(\"Node\").build(\"body\").field(\"body\", [TSTypeMember]);\n  def(\"TSExpressionWithTypeArguments\").bases(\"TSType\", \"TSHasOptionalTypeParameterInstantiation\").build(\"expression\", \"typeParameters\").field(\"expression\", TSEntityName);\n  def(\"TSInterfaceDeclaration\").bases(\"Declaration\", \"TSHasOptionalTypeParameters\").build(\"id\", \"body\").field(\"id\", TSEntityName).field(\"declare\", Boolean, defaults[\"false\"]).field(\"extends\", or([def(\"TSExpressionWithTypeArguments\")], null), defaults[\"null\"]).field(\"body\", def(\"TSInterfaceBody\"));\n  def(\"TSParameterProperty\").bases(\"Pattern\").build(\"parameter\").field(\"accessibility\", or(\"public\", \"private\", \"protected\", void 0), defaults[\"undefined\"]).field(\"readonly\", Boolean, defaults[\"false\"]).field(\"parameter\", or(def(\"Identifier\"), def(\"AssignmentPattern\")));\n  def(\"ClassProperty\").field(\"access\", // Not \"accessibility\"?\n  or(\"public\", \"private\", \"protected\", void 0), defaults[\"undefined\"]); // Defined already in es6 and babel-core.\n\n  def(\"ClassBody\").field(\"body\", [or(def(\"MethodDefinition\"), def(\"VariableDeclarator\"), def(\"ClassPropertyDefinition\"), def(\"ClassProperty\"), def(\"ClassPrivateProperty\"), def(\"ClassMethod\"), def(\"ClassPrivateMethod\"), // Just need to add these types:\n  def(\"TSDeclareMethod\"), TSTypeMember)]);\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}