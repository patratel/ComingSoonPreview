{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n */\n\nvar parse = require('url').parse;\n\nvar debug = require('debug')('get-uri');\n/**\n * Module exports.\n */\n\n\nmodule.exports = exports = getUri;\n/**\n * Supported \"protocols\".\n */\n\nexports.protocols = {\n  data: require('./data'),\n  file: require('./file'),\n  ftp: require('./ftp'),\n  http: require('./http'),\n  https: require('./https')\n};\n/**\n * Async function that returns a `stream.Readable` instance to the\n * callback function that will output the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @param {Function} fn callback function\n * @api public\n */\n\nfunction getUri(uri, opts, fn) {\n  debug('getUri(%o)', uri);\n\n  if ('function' == typeof opts) {\n    fn = opts;\n    opts = null;\n  }\n\n  if ('function' != typeof fn) {\n    throw new TypeError('a callback function must be provided');\n  }\n\n  if (!uri) return fn(new TypeError('must pass in a URI to \"get\"'));\n  var parsed = parse(uri);\n  var protocol = parsed.protocol;\n  if (!protocol) return fn(new TypeError('URI does not contain a protocol: ' + uri)); // strip trailing :\n\n  protocol = protocol.replace(/\\:$/, '');\n  var getter = exports.protocols[protocol];\n  if ('function' != typeof getter) return fn(new TypeError('unsupported protocol \"' + protocol + '\" specified in URI: ' + uri));\n  getter(parsed, opts || {}, fn);\n}","map":null,"metadata":{},"sourceType":"script"}