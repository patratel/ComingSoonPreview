{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar FTP = require('ftp');\n\nvar path = require('path');\n\nvar NotFoundError = require('./notfound');\n\nvar NotModifiedError = require('./notmodified');\n\nvar debug = require('debug')('get-uri:ftp');\n/**\n * Module exports.\n */\n\n\nmodule.exports = get;\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n *\n * @api protected\n */\n\nfunction get(parsed, opts, fn) {\n  var cache = opts.cache;\n  var client = new FTP();\n  var filepath = parsed.pathname;\n  var lastModified;\n  client.once('error', onerror);\n  client.once('ready', onready);\n  client.once('greeting', ongreeting);\n\n  function onready() {\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    client.lastMod(filepath, onlastmod);\n  }\n\n  function ongreeting(greeting) {\n    debug('FTP greeting: %o', greeting);\n  }\n\n  function onerror(err) {\n    client.end();\n    fn(err);\n  }\n\n  function onfile(err, stream) {\n    if (err) return onerror(err);\n    stream.once('end', onend);\n    stream.lastModified = lastModified;\n    fn(null, stream);\n  }\n\n  function onend() {\n    // close the FTP client socket connection\n    client.end();\n  }\n\n  function getFile() {\n    client.get(filepath, onfile);\n  }\n\n  function onlastmod(err, lastmod) {\n    // handle the \"file not found\" error code\n    if (err) {\n      if (550 == err.code) {\n        onerror(new NotFoundError());\n      } // any other error then we'll try the LIST command instead\n\n    }\n\n    if (lastmod) {\n      setLastMod(lastmod);\n    } else {\n      // try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      var dir = path.dirname(filepath);\n      client.list(dir, onlist);\n    }\n  }\n\n  function setLastMod(lastmod) {\n    lastModified = lastmod;\n\n    if (cache && isNotModified()) {\n      // file is the same as in the \"cache\", return a not modified error\n      onerror(new NotModifiedError());\n    } else {\n      // XXX: a small timeout seemed necessary otherwise FTP servers\n      // were returning empty sockets for the file occasionally\n      setTimeout(client.get.bind(client, filepath, onfile), 10);\n    }\n  }\n\n  function onlist(err, list) {\n    if (err) return onerror(err);\n    var name = path.basename(filepath); // attempt to find the \"entry\" with a matching \"name\"\n\n    var entry;\n\n    for (var i = 0; i < list.length; i++) {\n      entry = list[i];\n      debug('file %o: %o', i, entry.name);\n\n      if (entry.name == name) {\n        break;\n      }\n\n      entry = null;\n    }\n\n    if (entry) {\n      setLastMod(entry.date);\n    } else {\n      onerror(new NotFoundError());\n    }\n  } // called when `lastModified` is set, and a \"cache\" stream was provided\n\n\n  function isNotModified() {\n    return +cache.lastModified == +lastModified;\n  }\n\n  opts.host = parsed.hostname || parsed.host || 'localhost';\n  opts.port = parseInt(parsed.port, 10) || 21;\n  if (debug.enabled) opts.debug = debug; // TODO: add auth\n\n  client.connect(opts);\n}","map":null,"metadata":{},"sourceType":"script"}