{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\n\nvar BaseType =\n/** @class */\nfunction () {\n  function BaseType() {}\n\n  BaseType.prototype.assert = function (value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n\n    return true;\n  };\n\n  BaseType.prototype.arrayOf = function () {\n    var elemType = this;\n    return new ArrayType(elemType);\n  };\n\n  return BaseType;\n}();\n\nvar ArrayType =\n/** @class */\nfunction (_super) {\n  __extends(ArrayType, _super);\n\n  function ArrayType(elemType) {\n    var _this = _super.call(this) || this;\n\n    _this.elemType = elemType;\n    _this.kind = \"ArrayType\";\n    return _this;\n  }\n\n  ArrayType.prototype.toString = function () {\n    return \"[\" + this.elemType + \"]\";\n  };\n\n  ArrayType.prototype.check = function (value, deep) {\n    var _this = this;\n\n    return Array.isArray(value) && value.every(function (elem) {\n      return _this.elemType.check(elem, deep);\n    });\n  };\n\n  return ArrayType;\n}(BaseType);\n\nvar IdentityType =\n/** @class */\nfunction (_super) {\n  __extends(IdentityType, _super);\n\n  function IdentityType(value) {\n    var _this = _super.call(this) || this;\n\n    _this.value = value;\n    _this.kind = \"IdentityType\";\n    return _this;\n  }\n\n  IdentityType.prototype.toString = function () {\n    return String(this.value);\n  };\n\n  IdentityType.prototype.check = function (value, deep) {\n    var result = value === this.value;\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return IdentityType;\n}(BaseType);\n\nvar ObjectType =\n/** @class */\nfunction (_super) {\n  __extends(ObjectType, _super);\n\n  function ObjectType(fields) {\n    var _this = _super.call(this) || this;\n\n    _this.fields = fields;\n    _this.kind = \"ObjectType\";\n    return _this;\n  }\n\n  ObjectType.prototype.toString = function () {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  };\n\n  ObjectType.prototype.check = function (value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every(function (field) {\n      return field.type.check(value[field.name], deep);\n    });\n  };\n\n  return ObjectType;\n}(BaseType);\n\nvar OrType =\n/** @class */\nfunction (_super) {\n  __extends(OrType, _super);\n\n  function OrType(types) {\n    var _this = _super.call(this) || this;\n\n    _this.types = types;\n    _this.kind = \"OrType\";\n    return _this;\n  }\n\n  OrType.prototype.toString = function () {\n    return this.types.join(\" | \");\n  };\n\n  OrType.prototype.check = function (value, deep) {\n    return this.types.some(function (type) {\n      return type.check(value, deep);\n    });\n  };\n\n  return OrType;\n}(BaseType);\n\nvar PredicateType =\n/** @class */\nfunction (_super) {\n  __extends(PredicateType, _super);\n\n  function PredicateType(name, predicate) {\n    var _this = _super.call(this) || this;\n\n    _this.name = name;\n    _this.predicate = predicate;\n    _this.kind = \"PredicateType\";\n    return _this;\n  }\n\n  PredicateType.prototype.toString = function () {\n    return this.name;\n  };\n\n  PredicateType.prototype.check = function (value, deep) {\n    var result = this.predicate(value, deep);\n\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n\n    return result;\n  };\n\n  return PredicateType;\n}(BaseType);\n\nvar Def =\n/** @class */\nfunction () {\n  function Def(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    this.baseNames = [];\n    this.ownFields = Object.create(null); // Includes own typeName. Populated during finalization.\n\n    this.allSupertypes = Object.create(null); // Linear inheritance hierarchy. Populated during finalization.\n\n    this.supertypeList = []; // Includes inherited fields.\n\n    this.allFields = Object.create(null); // Non-hidden keys of allFields.\n\n    this.fieldNames = []; // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n\n    this.finalized = false; // False by default until .build(...) is called on an instance.\n\n    this.buildable = false;\n    this.buildParams = [];\n  }\n\n  Def.prototype.isSupertypeOf = function (that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n\n      return hasOwn.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  };\n\n  Def.prototype.checkAllFields = function (value, deep) {\n    var allFields = this.allFields;\n\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  };\n\n  Def.prototype.bases = function () {\n    var supertypeNames = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      supertypeNames[_i] = arguments[_i];\n    }\n\n    var bases = this.baseNames;\n\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n\n      return this;\n    }\n\n    supertypeNames.forEach(function (baseName) {\n      // This indexOf lookup may be O(n), but the typical number of base\n      // names is very small, and indexOf is a native Array method.\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this; // For chaining.\n  };\n\n  return Def;\n}();\n\nexports.Def = Def;\n\nvar Field =\n/** @class */\nfunction () {\n  function Field(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    this.hidden = !!hidden;\n  }\n\n  Field.prototype.toString = function () {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  };\n\n  Field.prototype.getValue = function (obj) {\n    var value = obj[this.name];\n\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n\n    return value;\n  };\n\n  return Field;\n}();\n\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function (key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n\n  return JSON.stringify(value);\n}\n\nfunction typesPlugin(_fork) {\n  var Type = {\n    or: function () {\n      var types = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        types[_i] = arguments[_i];\n      }\n\n      return new OrType(types.map(function (type) {\n        return Type.from(type);\n      }));\n    },\n    from: function (value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      } // The Def type is used as a helper for constructing compound\n      // interface types for AST nodes.\n\n\n      if (value instanceof Def) {\n        return value.type;\n      } // Support [ElemType] syntax.\n\n\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n\n        return new ArrayType(Type.from(value[0]));\n      } // Support { someField: FieldType, ... } syntax.\n\n\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map(function (name) {\n          return new Field(name, Type.from(value[name], name));\n        }));\n      }\n\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n\n        return new PredicateType(name, value);\n      } // As a last resort, toType returns a type that matches any value that\n      // is === from. This is primarily useful for literal values like\n      // toType(null), but it has the additional advantage of allowing\n      // toType to be a total function.\n\n\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def: function (typeName) {\n      return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef: function (typeName) {\n      return hasOwn.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n  var builtInTypes = {};\n\n  function defBuiltInType(example, name) {\n    var objStr = objToStr.call(example);\n    var type = new PredicateType(name, function (value) {\n      return objToStr.call(value) === objStr;\n    });\n    builtInTypes[name] = type;\n\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n\n    return type;\n  } // These types check the underlying [[Class]] attribute of the given\n  // value, rather than using the problematic typeof operator. Note however\n  // that no subtyping is considered; so, for instance, isObject.check\n  // returns false for [], /./, new Date, and null.\n\n\n  var isString = defBuiltInType(\"truthy\", \"string\");\n  var isFunction = defBuiltInType(function () {}, \"function\");\n  var isArray = defBuiltInType([], \"array\");\n  var isObject = defBuiltInType({}, \"object\");\n  var isRegExp = defBuiltInType(/./, \"RegExp\");\n  var isDate = defBuiltInType(new Date(), \"Date\");\n  var isNumber = defBuiltInType(3, \"number\");\n  var isBoolean = defBuiltInType(true, \"boolean\");\n  var isNull = defBuiltInType(null, \"null\");\n  var isUndefined = defBuiltInType(void 0, \"undefined\"); // In order to return the same Def instance every time Type.def is called\n  // with a particular name, those instances need to be stored in a cache.\n\n  var defCache = Object.create(null);\n\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n\n      if (typeof type === \"string\" && hasOwn.call(defCache, type)) {\n        var d = defCache[type];\n\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  var DefImpl =\n  /** @class */\n  function (_super) {\n    __extends(DefImpl, _super);\n\n    function DefImpl(typeName) {\n      var _this = _super.call(this, new PredicateType(typeName, function (value, deep) {\n        return _this.check(value, deep);\n      }), typeName) || this;\n\n      return _this;\n    }\n\n    DefImpl.prototype.check = function (value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n      } // A Def type can only match an object value.\n\n\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n\n      var vDef = defFromValue(value);\n\n      if (!vDef) {\n        // If we couldn't infer the Def associated with the given value,\n        // and we expected it to be a SourceLocation or a Position, it was\n        // probably just missing a \"type\" field (because Esprima does not\n        // assign a type property to such nodes). Be optimistic and let\n        // this.checkAllFields make the final decision.\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        } // Calling this.checkAllFields for any other type of node is both\n        // bad for performance and way too forgiving.\n\n\n        return false;\n      } // If checking deeply and vDef === this, then we only need to call\n      // checkAllFields once. Calling checkAllFields is too strict when deep\n      // is false, because then we only care about this.isSupertypeOf(vDef).\n\n\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      } // In most cases we rely exclusively on isSupertypeOf to make O(1)\n      // subtyping determinations. This suffices in most situations outside\n      // of unit tests, since interface conformance is checked whenever new\n      // instances are created using builder functions.\n\n\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      } // The exception is when deep is true; then, we recursively check all\n      // fields.\n\n\n      if (!deep) {\n        return true;\n      } // Use the more specific Def (vDef) to perform the deep check, but\n      // shallow-check fields defined by the less specific Def (this).\n\n\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    };\n\n    DefImpl.prototype.build = function () {\n      var _this = this;\n\n      var buildParams = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        buildParams[_i] = arguments[_i];\n      } // Calling Def.prototype.build multiple times has the effect of merely\n      // redefining this property.\n\n\n      this.buildParams = buildParams;\n\n      if (this.buildable) {\n        // If this Def is already buildable, update self.buildParams and\n        // continue using the old builder function.\n        return this;\n      } // Every buildable type will have its \"type\" field filled in\n      // automatically. This includes types that are not subtypes of Node,\n      // like SourceLocation, but that seems harmless (TODO?).\n\n\n      this.field(\"type\", String, function () {\n        return _this.typeName;\n      }); // Override Dp.buildable for this Def instance.\n\n      this.buildable = true;\n\n      var addParam = function (built, param, arg, isArgAvailable) {\n        if (hasOwn.call(built, param)) return;\n        var all = _this.allFields;\n\n        if (!hasOwn.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n\n        var field = all[param];\n        var type = field.type;\n        var value;\n\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          // Expose the partially-built object to the default\n          // function as its `this` object.\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + _this.typeName + \"(\" + _this.buildParams.map(function (name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n\n        if (!type.check(value)) {\n          throw new Error(shallowStringify(value) + \" does not match field \" + field + \" of type \" + _this.typeName);\n        }\n\n        built[param] = value;\n      }; // Calling the builder function will construct an instance of the Def,\n      // with positional arguments mapped to the fields original passed to .build.\n      // If not enough arguments are provided, the default value for the remaining fields\n      // will be used.\n\n\n      var builder = function () {\n        var args = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n\n        var argc = args.length;\n\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n\n        _this.buildParams.forEach(function (param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n\n        Object.keys(_this.allFields).forEach(function (param) {\n          // Use the default value.\n          addParam(built, param, null, false);\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      }; // Calling .from on the builder function will construct an instance of the Def,\n      // using field values from the passed object. For fields missing from the passed object,\n      // their default value will be used.\n\n\n      builder.from = function (obj) {\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n\n        var built = Object.create(nodePrototype);\n        Object.keys(_this.allFields).forEach(function (param) {\n          if (hasOwn.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        }); // Make sure that the \"type\" field was filled automatically.\n\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n\n        return built;\n      };\n\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    }; // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n\n\n    DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this; // For chaining.\n    };\n\n    DefImpl.prototype.finalize = function () {\n      var _this = this; // It's not an error to finalize a type more than once, but only the\n      // first call to .finalize does anything.\n\n\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach(function (name) {\n          var def = defCache[name];\n\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(_this.typeName);\n            throw new Error(message);\n          }\n        }); // TODO Warn if fields are overridden with incompatible types.\n\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n\n        for (var fieldName in allFields) {\n          if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        } // Types are exported only once they have been finalized.\n\n\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true; // A linearization of the inheritance hierarchy.\n\n        populateSupertypeList(this.typeName, this.supertypeList);\n\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    };\n\n    return DefImpl;\n  }(Def); // Note that the list returned by this function is a copy of the internal\n  // supertypeList, *without* the typeName itself as the first element.\n\n\n  function getSupertypeNames(typeName) {\n    if (!hasOwn.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n\n    var d = defCache[typeName];\n\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n\n    return d.supertypeList.slice(1);\n  } // Returns an object mapping from every known type in the defCache to the\n  // most specific supertype whose name is an own property of the candidates\n  // object.\n\n\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n\n        if (hasOwn.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n\n    return table;\n  }\n\n  var builders = Object.create(null); // This object is used as prototype for any node created by a builder.\n\n  var nodePrototype = {}; // Call this function to define a new method to be shared by all AST\n  // nodes. The replaced method (if any) is returned for easy wrapping.\n\n  function defineMethod(name, func) {\n    var old = nodePrototype[name]; // Pass undefined as func to delete nodePrototype[name].\n\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        configurable: true,\n        value: func\n      });\n    }\n\n    return old;\n  }\n\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n      var len = upperCasePrefix.length;\n\n      switch (len) {\n        case 0:\n          return \"\";\n        // If there's only one initial capital letter, just lower-case it.\n\n        case 1:\n          return upperCasePrefix.toLowerCase();\n\n        default:\n          // If there's more than one initial capital letter, lower-case\n          // all but the last one, so that XMLDefaultDeclaration (for\n          // example) becomes xmlDefaultDeclaration.\n          return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n\n  var namedTypes = {}; // Like Object.keys, but aware of what fields each AST type should have.\n\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n\n    if (\"type\" in object) {\n      throw new Error(\"did not recognize object of type \" + JSON.stringify(object.type));\n    }\n\n    return Object.keys(object);\n  } // Get the value of an object property, taking object.type and default\n  // functions into account.\n\n\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n\n    if (d) {\n      var field = d.allFields[fieldName];\n\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n\n    return object && object[fieldName];\n  } // Iterate over all defined fields of an object, including those missing\n  // or undefined, passing each field name and effective value (as returned\n  // by getFieldValue) to the callback. If the object has no corresponding\n  // Def, the callback will never be called.\n\n\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function (name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Similar to eachField, except that iteration stops as soon as the\n  // callback returns a truthy value. Like Array.prototype.some, the final\n  // result is either true or false to indicates whether the callback\n  // returned true for any element or not.\n\n\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function (name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  } // Adds an additional builder for Expression subtypes\n  // that wraps the built Expression in an ExpressionStatements.\n\n\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName); // skip if the builder already exists\n\n    if (builders[wrapperName]) return; // the builder function to wrap with builders.ExpressionStatement\n\n    var wrapped = builders[getBuilderName(typeName)]; // skip if there is nothing to wrap\n\n    if (!wrapped) return;\n\n    var builder = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n\n    builder.from = function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n\n    builders[wrapperName] = builder;\n  }\n\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = Object.create(null);\n\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      } // If we saw typeName earlier in the breadth-first traversal,\n      // delete the last-seen occurrence.\n\n\n      if (hasOwn.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      } // Record the new index of the last-seen occurrence of typeName.\n\n\n      lastSeen[typeName] = pos; // Enqueue the base names of this type.\n\n      list.push.apply(list, d.baseNames);\n    } // Compaction loop to remove array holes.\n\n\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n\n    list.length = to;\n  }\n\n  function extend(into, from) {\n    Object.keys(from).forEach(function (name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n\n  function finalize() {\n    Object.keys(defCache).forEach(function (name) {\n      defCache[name].finalize();\n    });\n  }\n\n  return {\n    Type: Type,\n    builtInTypes: builtInTypes,\n    getSupertypeNames: getSupertypeNames,\n    computeSupertypeLookupTable: computeSupertypeLookupTable,\n    builders: builders,\n    defineMethod: defineMethod,\n    getBuilderName: getBuilderName,\n    getStatementBuilderName: getStatementBuilderName,\n    namedTypes: namedTypes,\n    getFieldNames: getFieldNames,\n    getFieldValue: getFieldValue,\n    eachField: eachField,\n    someField: someField,\n    finalize: finalize\n  };\n}\n\nexports.default = typesPlugin;\n;","map":null,"metadata":{},"sourceType":"script"}