{"ast":null,"code":"/**\n * Module dependencies.\n */\nvar types = require('ast-types');\n\nvar esprima = require('esprima');\n\nvar escodegen = require('escodegen');\n/**\n * Helper functions.\n */\n\n\nvar n = types.namedTypes;\nvar b = types.builders;\n/**\n * Module exports.\n */\n\nmodule.exports = degenerator;\n/**\n * Turns sync JavaScript code into an JavaScript with async Generator Functions.\n *\n * @param {String} jsStr JavaScript string to convert\n * @param {Array} names Array of function names to add `yield` operators to\n * @return {String} Converted JavaScript string with Generator functions injected\n * @api public\n */\n\nfunction degenerator(jsStr, names) {\n  if (!Array.isArray(names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n\n  var ast = esprima.parse(jsStr); // duplicate the `names` array since it's rude to augment the user-provided\n  // array\n\n  names = names.slice(0); // first pass is to find the `function` nodes and turn them into `function *`\n  // generator functions. We also add the names of the functions to the `names`\n  // array\n\n  types.visit(ast, {\n    visitFunction: function (path) {\n      if (path.node.id) {\n        // got a \"function\" expression/statement,\n        // convert it into a \"generator function\"\n        path.node.generator = true; // add function name to `names` array\n\n        names.push(path.node.id.name);\n      }\n\n      this.traverse(path);\n    }\n  }); // second pass is for adding `yield` statements to any function\n  // invocations that match the given `names` array.\n\n  types.visit(ast, {\n    visitCallExpression: function (path) {\n      if (checkNames(path.node, names)) {\n        // a \"function invocation\" expression,\n        // we need to inject a `YieldExpression`\n        var name = path.name;\n        var parent = path.parent.node;\n        var delegate = false;\n        var expr = b.yieldExpression(path.node, delegate);\n\n        if (parent['arguments']) {\n          // parent is a `CallExpression` type\n          parent['arguments'][name] = expr;\n        } else {\n          parent[name] = expr;\n        }\n      }\n\n      this.traverse(path);\n    }\n  });\n  return escodegen.generate(ast);\n}\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\n\n\nfunction checkNames(node, names) {\n  var name;\n  var callee = node.callee;\n\n  if ('Identifier' == callee.type) {\n    name = callee.name;\n  } else if ('MemberExpression' == callee.type) {\n    name = callee.object.name + '.' + (callee.property.name || callee.property.raw);\n  } else if ('FunctionExpression' == callee.type) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error('don\\'t know how to get name for: ' + callee.type);\n  } // now that we have the `name`, check if any entries match in the `names` array\n\n\n  var n;\n\n  for (var i = 0; i < names.length; i++) {\n    n = names[i];\n\n    if (n.test) {\n      // regexp\n      if (n.test(name)) return true;\n    } else {\n      if (name == n) return true;\n    }\n  }\n\n  return false;\n}","map":null,"metadata":{},"sourceType":"script"}