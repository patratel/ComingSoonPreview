{"ast":null,"code":"'use strict';\n/**\n * Module dependencies.\n */\n\nvar co = require('co');\n\nvar vm = require('vm');\n\nvar parse = require('url').parse;\n\nvar thunkify = require('thunkify');\n\nvar degenerator = require('degenerator');\n/**\n * Built-in PAC functions.\n */\n\n\nvar dateRange = require('./dateRange');\n\nvar dnsDomainIs = require('./dnsDomainIs');\n\nvar dnsDomainLevels = require('./dnsDomainLevels');\n\nvar dnsResolve = require('./dnsResolve');\n\nvar isInNet = require('./isInNet');\n\nvar isPlainHostName = require('./isPlainHostName');\n\nvar isResolvable = require('./isResolvable');\n\nvar localHostOrDomainIs = require('./localHostOrDomainIs');\n\nvar myIpAddress = require('./myIpAddress');\n\nvar shExpMatch = require('./shExpMatch');\n\nvar timeRange = require('./timeRange');\n\nvar weekdayRange = require('./weekdayRange');\n/**\n * Module exports.\n */\n\n\nmodule.exports = generate;\n/**\n * Returns an asyncronous `FindProxyForURL` function from the\n * given JS string (from a PAC file).\n *\n * @param {String} str JS string\n * @param {Object} opts optional \"options\" object\n * @return {Function} async resolver function\n */\n\nfunction generate(_str, opts) {\n  var i;\n  var str = String(_str); // the sandbox to use for the vm\n\n  var sandbox = {\n    dateRange: dateRange,\n    dnsDomainIs: dnsDomainIs,\n    dnsDomainLevels: dnsDomainLevels,\n    dnsResolve: dnsResolve,\n    isInNet: isInNet,\n    isPlainHostName: isPlainHostName,\n    isResolvable: isResolvable,\n    localHostOrDomainIs: localHostOrDomainIs,\n    myIpAddress: myIpAddress,\n    shExpMatch: shExpMatch,\n    timeRange: timeRange,\n    weekdayRange: weekdayRange\n  }; // copy the properties from the user-provided `sandbox` onto ours\n\n  if (opts && opts.sandbox) {\n    for (i in opts.sandbox) {\n      sandbox[i] = opts.sandbox[i];\n    }\n  } // construct the array of async function names to add `yield` calls to.\n  // user-provided async functions added to the `sandbox` must have an\n  // `async = true` property set on the function instance\n\n\n  var names = [];\n\n  for (i in sandbox) {\n    if (sandbox[i].async) {\n      names.push(i);\n      sandbox[i] = thunkify(sandbox[i]);\n    }\n  } //console.log(names);\n  // convert the JS FindProxyForURL function into a generator function\n\n\n  var js = degenerator(str, names); // filename of the pac file for the vm\n\n  var filename = opts && opts.filename || 'proxy.pac'; // evaluate the JS string and extract the FindProxyForURL generator function\n\n  var fn = vm.runInNewContext(js + ';FindProxyForURL', sandbox, filename);\n\n  if ('function' != typeof fn) {\n    throw new TypeError('PAC file JavaScript contents must define a `FindProxyForURL` function');\n  } // return the async resolver function\n\n\n  var resolver = co.wrap(fn);\n  return function FindProxyForURL(url, _host, _callback) {\n    let host;\n    let callback;\n\n    switch (arguments.length) {\n      case 3:\n        host = _host;\n        callback = _callback;\n        break;\n\n      case 2:\n        if (typeof _host === 'function') {\n          callback = _host;\n        } else {\n          host = _host;\n        }\n\n        break;\n    }\n\n    if (!host) {\n      host = parse(url).hostname;\n    }\n\n    const promise = resolver(url, host, callback);\n\n    if (typeof callback === 'function') {\n      toCallback(promise, callback);\n    } else {\n      return promise;\n    }\n  };\n}\n\nfunction toCallback(promise, callback) {\n  let called = false;\n\n  function resolve(rtn) {\n    if (called) return;\n    called = true;\n    callback(null, rtn);\n  }\n\n  function reject(err) {\n    if (called) return;\n    called = true;\n    callback(err);\n  }\n\n  promise.then(resolve, reject);\n}","map":null,"metadata":{},"sourceType":"script"}