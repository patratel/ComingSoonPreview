{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nvar node_path_1 = __importDefault(require(\"./node-path\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction pathVisitorPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var NodePath = fork.use(node_path_1.default);\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isFunction = types.builtInTypes.function;\n  var undefined;\n\n  var PathVisitor = function PathVisitor() {\n    if (!(this instanceof PathVisitor)) {\n      throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n    } // Permanent state.\n\n\n    this._reusableContextStack = [];\n    this._methodNameTable = computeMethodNameTable(this);\n    this._shouldVisitComments = hasOwn.call(this._methodNameTable, \"Block\") || hasOwn.call(this._methodNameTable, \"Line\");\n    this.Context = makeContextConstructor(this); // State reset every time PathVisitor.prototype.visit is called.\n\n    this._visiting = false;\n    this._changeReported = false;\n  };\n\n  function computeMethodNameTable(visitor) {\n    var typeNames = Object.create(null);\n\n    for (var methodName in visitor) {\n      if (/^visit[A-Z]/.test(methodName)) {\n        typeNames[methodName.slice(\"visit\".length)] = true;\n      }\n    }\n\n    var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n    var methodNameTable = Object.create(null);\n    var typeNameKeys = Object.keys(supertypeTable);\n    var typeNameCount = typeNameKeys.length;\n\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNameKeys[i];\n      methodName = \"visit\" + supertypeTable[typeName];\n\n      if (isFunction.check(visitor[methodName])) {\n        methodNameTable[typeName] = methodName;\n      }\n    }\n\n    return methodNameTable;\n  }\n\n  PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n    if (methods instanceof PathVisitor) {\n      return methods;\n    }\n\n    if (!isObject.check(methods)) {\n      // An empty visitor?\n      return new PathVisitor();\n    }\n\n    var Visitor = function Visitor() {\n      if (!(this instanceof Visitor)) {\n        throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n      }\n\n      PathVisitor.call(this);\n    };\n\n    var Vp = Visitor.prototype = Object.create(PVp);\n    Vp.constructor = Visitor;\n    extend(Vp, methods);\n    extend(Visitor, PathVisitor);\n    isFunction.assert(Visitor.fromMethodsObject);\n    isFunction.assert(Visitor.visit);\n    return new Visitor();\n  };\n\n  function extend(target, source) {\n    for (var property in source) {\n      if (hasOwn.call(source, property)) {\n        target[property] = source[property];\n      }\n    }\n\n    return target;\n  }\n\n  PathVisitor.visit = function visit(node, methods) {\n    return PathVisitor.fromMethodsObject(methods).visit(node);\n  };\n\n  var PVp = PathVisitor.prototype;\n\n  PVp.visit = function () {\n    if (this._visiting) {\n      throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" + \"Try this.visit(path) or this.traverse(path) instead.\");\n    } // Private state that needs to be reset before every traversal.\n\n\n    this._visiting = true;\n    this._changeReported = false;\n    this._abortRequested = false;\n    var argc = arguments.length;\n    var args = new Array(argc);\n\n    for (var i = 0; i < argc; ++i) {\n      args[i] = arguments[i];\n    }\n\n    if (!(args[0] instanceof NodePath)) {\n      args[0] = new NodePath({\n        root: args[0]\n      }).get(\"root\");\n    } // Called with the same arguments as .visit.\n\n\n    this.reset.apply(this, args);\n    var didNotThrow;\n\n    try {\n      var root = this.visitWithoutReset(args[0]);\n      didNotThrow = true;\n    } finally {\n      this._visiting = false;\n\n      if (!didNotThrow && this._abortRequested) {\n        // If this.visitWithoutReset threw an exception and\n        // this._abortRequested was set to true, return the root of\n        // the AST instead of letting the exception propagate, so that\n        // client code does not have to provide a try-catch block to\n        // intercept the AbortRequest exception.  Other kinds of\n        // exceptions will propagate without being intercepted and\n        // rethrown by a catch block, so their stacks will accurately\n        // reflect the original throwing context.\n        return args[0].value;\n      }\n    }\n\n    return root;\n  };\n\n  PVp.AbortRequest = function AbortRequest() {};\n\n  PVp.abort = function () {\n    var visitor = this;\n    visitor._abortRequested = true;\n    var request = new visitor.AbortRequest(); // If you decide to catch this exception and stop it from propagating,\n    // make sure to call its cancel method to avoid silencing other\n    // exceptions that might be thrown later in the traversal.\n\n    request.cancel = function () {\n      visitor._abortRequested = false;\n    };\n\n    throw request;\n  };\n\n  PVp.reset = function (_path\n  /*, additional arguments */\n  ) {// Empty stub; may be reassigned or overridden by subclasses.\n  };\n\n  PVp.visitWithoutReset = function (path) {\n    if (this instanceof this.Context) {\n      // Since this.Context.prototype === this, there's a chance we\n      // might accidentally call context.visitWithoutReset. If that\n      // happens, re-invoke the method against context.visitor.\n      return this.visitor.visitWithoutReset(path);\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n    var methodName = value && typeof value === \"object\" && typeof value.type === \"string\" && this._methodNameTable[value.type];\n\n    if (methodName) {\n      var context = this.acquireContext(path);\n\n      try {\n        return context.invokeVisitorMethod(methodName);\n      } finally {\n        this.releaseContext(context);\n      }\n    } else {\n      // If there was no visitor method to call, visit the children of\n      // this node generically.\n      return visitChildren(path, this);\n    }\n  };\n\n  function visitChildren(path, visitor) {\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n\n    var value = path.value;\n\n    if (isArray.check(value)) {\n      path.each(visitor.visitWithoutReset, visitor);\n    } else if (!isObject.check(value)) {// No children to visit.\n    } else {\n      var childNames = types.getFieldNames(value); // The .comments field of the Node type is hidden, so we only\n      // visit it if the visitor defines visitBlock or visitLine, and\n      // value.comments is defined.\n\n      if (visitor._shouldVisitComments && value.comments && childNames.indexOf(\"comments\") < 0) {\n        childNames.push(\"comments\");\n      }\n\n      var childCount = childNames.length;\n      var childPaths = [];\n\n      for (var i = 0; i < childCount; ++i) {\n        var childName = childNames[i];\n\n        if (!hasOwn.call(value, childName)) {\n          value[childName] = types.getFieldValue(value, childName);\n        }\n\n        childPaths.push(path.get(childName));\n      }\n\n      for (var i = 0; i < childCount; ++i) {\n        visitor.visitWithoutReset(childPaths[i]);\n      }\n    }\n\n    return path.value;\n  }\n\n  PVp.acquireContext = function (path) {\n    if (this._reusableContextStack.length === 0) {\n      return new this.Context(path);\n    }\n\n    return this._reusableContextStack.pop().reset(path);\n  };\n\n  PVp.releaseContext = function (context) {\n    if (!(context instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    this._reusableContextStack.push(context);\n\n    context.currentPath = null;\n  };\n\n  PVp.reportChanged = function () {\n    this._changeReported = true;\n  };\n\n  PVp.wasChangeReported = function () {\n    return this._changeReported;\n  };\n\n  function makeContextConstructor(visitor) {\n    function Context(path) {\n      if (!(this instanceof Context)) {\n        throw new Error(\"\");\n      }\n\n      if (!(this instanceof PathVisitor)) {\n        throw new Error(\"\");\n      }\n\n      if (!(path instanceof NodePath)) {\n        throw new Error(\"\");\n      }\n\n      Object.defineProperty(this, \"visitor\", {\n        value: visitor,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      });\n      this.currentPath = path;\n      this.needToCallTraverse = true;\n      Object.seal(this);\n    }\n\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    } // Note that the visitor object is the prototype of Context.prototype,\n    // so all visitor methods are inherited by context objects.\n\n\n    var Cp = Context.prototype = Object.create(visitor);\n    Cp.constructor = Context;\n    extend(Cp, sharedContextProtoMethods);\n    return Context;\n  } // Every PathVisitor has a different this.Context constructor and\n  // this.Context.prototype object, but those prototypes can all use the\n  // same reset, invokeVisitorMethod, and traverse function objects.\n\n\n  var sharedContextProtoMethods = Object.create(null);\n\n  sharedContextProtoMethods.reset = function reset(path) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.currentPath = path;\n    this.needToCallTraverse = true;\n    return this;\n  };\n\n  sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    var result = this.visitor[methodName].call(this, this.currentPath);\n\n    if (result === false) {\n      // Visitor methods return false to indicate that they have handled\n      // their own traversal needs, and we should not complain if\n      // this.needToCallTraverse is still true.\n      this.needToCallTraverse = false;\n    } else if (result !== undefined) {\n      // Any other non-undefined value returned from the visitor method\n      // is interpreted as a replacement value.\n      this.currentPath = this.currentPath.replace(result)[0];\n\n      if (this.needToCallTraverse) {\n        // If this.traverse still hasn't been called, visit the\n        // children of the replacement node.\n        this.traverse(this.currentPath);\n      }\n    }\n\n    if (this.needToCallTraverse !== false) {\n      throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n    }\n\n    var path = this.currentPath;\n    return path && path.value;\n  };\n\n  sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n  };\n\n  sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n\n    this.needToCallTraverse = false;\n    return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n  };\n\n  sharedContextProtoMethods.reportChanged = function reportChanged() {\n    this.visitor.reportChanged();\n  };\n\n  sharedContextProtoMethods.abort = function abort() {\n    this.needToCallTraverse = false;\n    this.visitor.abort();\n  };\n\n  return PathVisitor;\n}\n\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}