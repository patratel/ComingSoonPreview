{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction scopePlugin(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var namedTypes = types.namedTypes;\n  var Node = namedTypes.Node;\n  var Expression = namedTypes.Expression;\n  var isArray = types.builtInTypes.array;\n  var b = types.builders;\n\n  var Scope = function Scope(path, parentScope) {\n    if (!(this instanceof Scope)) {\n      throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n\n    ScopeType.assert(path.value);\n    var depth;\n\n    if (parentScope) {\n      if (!(parentScope instanceof Scope)) {\n        throw new Error(\"\");\n      }\n\n      depth = parentScope.depth + 1;\n    } else {\n      parentScope = null;\n      depth = 0;\n    }\n\n    Object.defineProperties(this, {\n      path: {\n        value: path\n      },\n      node: {\n        value: path.value\n      },\n      isGlobal: {\n        value: !parentScope,\n        enumerable: true\n      },\n      depth: {\n        value: depth\n      },\n      parent: {\n        value: parentScope\n      },\n      bindings: {\n        value: {}\n      },\n      types: {\n        value: {}\n      }\n    });\n  };\n\n  var scopeTypes = [// Program nodes introduce global scopes.\n  namedTypes.Program, // Function is the supertype of FunctionExpression,\n  // FunctionDeclaration, ArrowExpression, etc.\n  namedTypes.Function, // In case you didn't know, the caught parameter shadows any variable\n  // of the same name in an outer scope.\n  namedTypes.CatchClause];\n  var ScopeType = Type.or.apply(Type, scopeTypes);\n\n  Scope.isEstablishedBy = function (node) {\n    return ScopeType.check(node);\n  };\n\n  var Sp = Scope.prototype; // Will be overridden after an instance lazily calls scanScope.\n\n  Sp.didScan = false;\n\n  Sp.declares = function (name) {\n    this.scan();\n    return hasOwn.call(this.bindings, name);\n  };\n\n  Sp.declaresType = function (name) {\n    this.scan();\n    return hasOwn.call(this.types, name);\n  };\n\n  Sp.declareTemporary = function (prefix) {\n    if (prefix) {\n      if (!/^[a-z$_]/i.test(prefix)) {\n        throw new Error(\"\");\n      }\n    } else {\n      prefix = \"t$\";\n    } // Include this.depth in the name to make sure the name does not\n    // collide with any variables in nested/enclosing scopes.\n\n\n    prefix += this.depth.toString(36) + \"$\";\n    this.scan();\n    var index = 0;\n\n    while (this.declares(prefix + index)) {\n      ++index;\n    }\n\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n  };\n\n  Sp.injectTemporary = function (identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n    var bodyPath = this.path.get(\"body\");\n\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n      bodyPath = bodyPath.get(\"body\");\n    }\n\n    bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n    return identifier;\n  };\n\n  Sp.scan = function (force) {\n    if (force || !this.didScan) {\n      for (var name in this.bindings) {\n        // Empty out this.bindings, just in cases.\n        delete this.bindings[name];\n      }\n\n      scanScope(this.path, this.bindings, this.types);\n      this.didScan = true;\n    }\n  };\n\n  Sp.getBindings = function () {\n    this.scan();\n    return this.bindings;\n  };\n\n  Sp.getTypes = function () {\n    this.scan();\n    return this.types;\n  };\n\n  function scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    ScopeType.assert(node);\n\n    if (namedTypes.CatchClause.check(node)) {\n      // A catch clause establishes a new scope but the only variable\n      // bound in that scope is the catch parameter. Any other\n      // declarations create bindings in the outer scope.\n      addPattern(path.get(\"param\"), bindings);\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n      addPattern(path.parent.get(\"id\"), bindings);\n    }\n\n    if (!node) {// None of the remaining cases matter if node is falsy.\n    } else if (isArray.check(node)) {\n      path.each(function (childPath) {\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    } else if (namedTypes.Function.check(node)) {\n      path.get(\"params\").each(function (paramPath) {\n        addPattern(paramPath, bindings);\n      });\n      recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n    } else if (node.type === \"ImportSpecifier\" || node.type === \"ImportNamespaceSpecifier\" || node.type === \"ImportDefaultSpecifier\") {\n      addPattern( // Esprima used to use the .name field to refer to the local\n      // binding identifier for ImportSpecifier nodes, but .id for\n      // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n      // ESTree/Acorn/ESpree use .local for all three node types.\n      path.get(node.local ? \"local\" : node.name ? \"name\" : \"id\"), bindings);\n    } else if (Node.check(node) && !Expression.check(node)) {\n      types.eachField(node, function (name, child) {\n        var childPath = path.get(name);\n\n        if (!pathHasValue(childPath, child)) {\n          throw new Error(\"\");\n        }\n\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    }\n  }\n\n  function pathHasValue(path, value) {\n    if (path.value === value) {\n      return true;\n    } // Empty arrays are probably produced by defaults.emptyArray, in which\n    // case is makes sense to regard them as equivalent, if not ===.\n\n\n    if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n      return true;\n    }\n\n    return false;\n  }\n\n  function recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n\n    if (!node || Expression.check(node)) {// Ignore falsy values and Expressions.\n    } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node) && // TODO Broaden this to accept any pattern.\n      namedTypes.Identifier.check(node.param)) {\n        var catchParamName = node.param.name;\n        var hadBinding = hasOwn.call(bindings, catchParamName); // Any declarations that occur inside the catch body that do\n        // not have the same name as the catch parameter should count\n        // as bindings in the outer scope.\n\n        recursiveScanScope(path.get(\"body\"), bindings, scopeTypes); // If a new binding matching the catch parameter name was\n        // created while scanning the catch body, ignore it because it\n        // actually refers to the catch parameter and not the outer\n        // scope that we're currently scanning.\n\n        if (!hadBinding) {\n          delete bindings[catchParamName];\n        }\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n\n  function addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(bindings, pattern.name)) {\n        bindings[pattern.name].push(patternPath);\n      } else {\n        bindings[pattern.name] = [patternPath];\n      }\n    } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n      addPattern(patternPath.get('left'), bindings);\n    } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n      patternPath.get('properties').each(function (propertyPath) {\n        var property = propertyPath.value;\n\n        if (namedTypes.Pattern.check(property)) {\n          addPattern(propertyPath, bindings);\n        } else if (namedTypes.Property.check(property)) {\n          addPattern(propertyPath.get('value'), bindings);\n        } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n          addPattern(propertyPath.get('argument'), bindings);\n        }\n      });\n    } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n      patternPath.get('elements').each(function (elementPath) {\n        var element = elementPath.value;\n\n        if (namedTypes.Pattern.check(element)) {\n          addPattern(elementPath, bindings);\n        } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n          addPattern(elementPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('pattern'), bindings);\n    } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('argument'), bindings);\n    }\n  }\n\n  function addTypePattern(patternPath, types) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(types, pattern.name)) {\n        types[pattern.name].push(patternPath);\n      } else {\n        types[pattern.name] = [patternPath];\n      }\n    }\n  }\n\n  Sp.lookup = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declares(name)) break;\n\n    return scope;\n  };\n\n  Sp.lookupType = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declaresType(name)) break;\n\n    return scope;\n  };\n\n  Sp.getGlobalScope = function () {\n    var scope = this;\n\n    while (!scope.isGlobal) scope = scope.parent;\n\n    return scope;\n  };\n\n  return Scope;\n}\n\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}