{"ast":null,"code":"\"use strict\";\n\n;\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar types_1 = __importDefault(require(\"./types\"));\n\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var builtin = types.builtInTypes;\n  var isNumber = builtin.number; // An example of constructing a new type with arbitrary constraints from\n  // an existing type.\n\n  function geq(than) {\n    return Type.from(function (value) {\n      return isNumber.check(value) && value >= than;\n    }, isNumber + \" >= \" + than);\n  }\n\n  ; // Default value-returning functions that may optionally be passed as a\n  // third argument to Def.prototype.field.\n\n  var defaults = {\n    // Functions were used because (among other reasons) that's the most\n    // elegant way to allow for the emptyArray one always to give a new\n    // array instance.\n    \"null\": function () {\n      return null;\n    },\n    \"emptyArray\": function () {\n      return [];\n    },\n    \"false\": function () {\n      return false;\n    },\n    \"true\": function () {\n      return true;\n    },\n    \"undefined\": function () {},\n    \"use strict\": function () {\n      return \"use strict\";\n    }\n  };\n  var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);\n  var isPrimitive = Type.from(function (value) {\n    if (value === null) return true;\n    var type = typeof value;\n\n    if (type === \"object\" || type === \"function\") {\n      return false;\n    }\n\n    return true;\n  }, naiveIsPrimitive.toString());\n  return {\n    geq: geq,\n    defaults: defaults,\n    isPrimitive: isPrimitive\n  };\n}\n\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":null,"metadata":{},"sourceType":"script"}