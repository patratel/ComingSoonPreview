{"ast":null,"code":"/*\n * The MIT License (MIT)\n *\n * Copyright (c) 2015 Mailjet\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n */\nconst DEBUG_MODE = false;\nconst RESOURCE = 0;\nconst ID = 1;\nconst ACTION = 2;\n/*\n * Imports.\n *\n * qs is used to format the url from the provided parameters and method\n * _path will join a path according to the OS specifications\n * https will be used to make a secure http request to the API\n * fs will simply be used to read files\n */\n\nconst qs = require('querystring');\n\nconst request = require('superagent');\n\nconst Promise = require('bluebird');\n\nconst _path = require('path');\n\nconst JSONb = require('json-bigint')({\n  storeAsString: true\n});\n\nconst version = require('./package.json').version;\n/* Extend superagent request with proxy method */\n\n\nrequire('superagent-proxy')(request);\n/*\n * MailjetClient constructor.\n *\n * @qpi_key (optional) {String} mailjet account api key\n * @api_secret (optional) {String} mailjet account api secret\n * @options (optional) {Object} additional connection options\n *\n * If you don't know what this is about, sign up to Mailjet at:\n * https://www.mailjet.com/\n */\n\n\nfunction MailjetClient(api_key, api_secret, options, perform_api_call) {\n  return this.authStrategy(api_key, api_secret, options, perform_api_call);\n}\n/**\n * @param (optional){String} api_key || api_token\n * @param (optional){String} api_secret\n * @param (optional){Object} options \n * @param (optional){any} perform_api_call \n */\n\n\nMailjetClient.prototype.authStrategy = function (api_key, api_secret, options, perform_api_call) {\n  var isTokenRequired = this.isTokenRequired(api_key, api_secret, options, perform_api_call);\n  var self = this; // Check if api version requires toekn authentication\n  // This is one of the approaches, maybe there is better \n\n  if (isTokenRequired) {\n    // params are shifted one position to left as we don't have api secret any more\n    // api_key becomes api_token\n    // api_secret becomes options\n    // options becomes perform_api_call\n    return tokenAuthentication(api_key, api_secret, options);\n  } else {\n    // params are in correct order\n    return basicAuthentication(api_key, api_secret, options, perform_api_call);\n  }\n  /**\n   *\n   * @param (optional){String} api_key mailjet api key\n   * @param (optional){String} api_secret mailjet api secret\n   * @param (optional){Object} options additional connection options\n   * @param (optional){boolean} perform_api_call \n   */\n\n\n  function basicAuthentication(api_key, api_secret, options, perform_api_call) {\n    self.config = self.setConfig(options);\n    self.perform_api_call = perform_api_call || false; // To be updated according to the npm repo version\n\n    self.version = version;\n\n    if (api_key && api_secret) {\n      self.connect(api_key, api_secret, options);\n    }\n\n    return self;\n  }\n  /**\n   * \n   * @param (optional){String} api_token mailjet api token\n   * @param (optional){Object} options additional connection options\n   * @param (optional){boolean} perform_api_call \n   */\n\n\n  function tokenAuthentication(api_token, options, perform_api_call) {\n    self.perform_api_call = perform_api_call || false; // To be updated according to the npm repo version\n\n    self.version = version;\n\n    if (api_token) {\n      self.connect(api_token, options);\n    }\n\n    return self;\n  }\n};\n\nMailjetClient.prototype.isTokenRequired = function () {\n  var args = [].slice.call(arguments);\n  var vals = args.filter(a => a !== undefined);\n\n  if (DEBUG_MODE) {\n    console.log('Defined arguments: ' + JSON.stringify(vals));\n  }\n\n  return vals.length === 1 || vals.length >= 2 && typeof vals[1] === 'object';\n};\n\nMailjetClient.prototype.typeJson = function (body) {\n  var keys = Object.keys(body);\n\n  for (var i in keys) {\n    var key = keys[i];\n    body[key] = parseInt(body[key]) || body[key];\n  }\n\n  return body;\n};\n/*\n * [Static] connect.\n *\n * Return a nez connected instance of the MailjetClient class\n *\n * @k {String} mailjet qpi key\n * @s {String} mailjet api secret\n * @o {String} optional connection options\n *\n */\n\n\nMailjetClient.connect = function (k, s, o) {\n  return new MailjetClient().connect(k, s, o);\n};\n/*\n * connect.\n *\n * create a auth property from the api key and secret\n *\n * @apiKey || @apiToken {String}\n * @apiSecret {String}\n * @options {Object}\n *\n */\n\n\nMailjetClient.prototype.connect = function (apiKey, apiSecret, options) {\n  return this.connectStrategy(apiKey, apiSecret, options);\n};\n/**\n * @param (optional){String} apiKey || apiToken\n * @param (optional){String} apiSecret \n * @param (optional){Object} options \n */\n\n\nMailjetClient.prototype.connectStrategy = function (apiKey, apiSecret, options) {\n  var self = this;\n  var isTokenRequired = this.isTokenRequired(apiKey, apiSecret, options);\n\n  if (isTokenRequired) {\n    return tokenConnectStrategy(apiKey, apiSecret);\n  } else {\n    return basicConnectStrategy(apiKey, apiSecret, options);\n  }\n\n  function basicConnectStrategy(apiKey, apiSecret, options) {\n    setOptions(options);\n    self.apiKey = apiKey;\n    self.apiSecret = apiSecret;\n    return self;\n  }\n\n  function tokenConnectStrategy(apiToken, options) {\n    setOptions(options);\n    self.apiToken = apiToken;\n    return self;\n  }\n\n  function setOptions(options) {\n    self.options = options || {};\n\n    if (self.options) {\n      self.config = self.setConfig(options);\n    }\n  }\n};\n\nMailjetClient.prototype.setConfig = function (options) {\n  const config = require('./config');\n\n  if (typeof options === 'object' && options != null && options.length != 0) {\n    if (options.url) config.url = options.url;\n    if (options.version) config.version = options.version;\n    if (options.secured) config.secured = options.secured;\n    if (options.perform_api_call) config.perform_api_call = options.perform_api_call;\n  } else if (options != null) {\n    throw new Error('warning, your options variable is not a valid object.');\n  }\n\n  return config;\n};\n/*\n * path.\n *\n * Returns a formatted url from a http method and\n * a parameters object literal\n *\n * @resource {String}\n * @sub {String} REST/''/DATA\n * @params {Object literal} {name: value}\n *\n */\n\n\nMailjetClient.prototype.path = function (resource, sub, params, options) {\n  if (DEBUG_MODE) {\n    console.log('resource =', resource);\n    console.log('subPath =', sub);\n    console.log('filters =', params);\n  }\n\n  const url = options && 'url' in options ? options.url : this.config.url;\n  const api_version = options && 'version' in options ? options.version : this.config.version;\n\n  var base = _path.join(api_version, sub);\n\n  if (Object.keys(params).length === 0) {\n    return _path.join(url, base + '/' + resource);\n  }\n\n  var q = qs.stringify(params).replace(/%2B/g, '+');\n  return _path.join(url, base + '/' + resource + '/?' + q);\n};\n/*\n * httpRequest.\n *\n * @method {String} http method (GET/POST...)\n * @url {String} url path to be used for the request\n * @data {Object literal} additional data espacially for POST/PUT operations\n * @callback -optional {Function} called on response from the server, or on error\n *\n * @return a promise triggering 'success' on response\n * \t\tand error on error\n */\n\n\nMailjetClient.prototype.httpRequest = function (method, url, data, callback, perform_api_call) {\n  var req = request[method](url).set('user-agent', 'mailjet-api-v3-nodejs/' + this.version).set('Content-type', url.indexOf('text:plain') > -1 ? 'text/plain' : 'application/json');\n\n  if (this.apiToken) {\n    req.set('Authorization', 'Bearer ' + this.apiToken);\n  } else {\n    req.auth(this.apiKey, this.apiSecret);\n  }\n\n  if (this.options.proxyUrl) {\n    req = req.proxy(this.options.proxyUrl);\n  }\n\n  if (this.options.timeout) {\n    req = req.timeout(this.options.timeout);\n  }\n\n  const payload = method === 'post' || method === 'put' ? data : {};\n\n  if (DEBUG_MODE) {\n    console.log('Final url: ' + url);\n    console.log('body: ' + JSON.stringify(payload));\n  }\n\n  if (perform_api_call === false || this.perform_api_call) {\n    return Promise.resolve({\n      body: payload,\n      url: url\n    });\n  }\n\n  if (method === 'delete') {\n    method = 'del';\n  }\n\n  if (method === 'post' || method === 'put') {\n    req = req.send(data);\n  }\n\n  return new Promise(function (resolve, reject) {\n    const ret = function (err, result) {\n      return typeof callback === 'function' ? callback(err, result) : err ? reject(err) : resolve(result);\n    };\n\n    req.end(function (err, result) {\n      var body;\n\n      try {\n        body = JSONb.parse(result.text);\n      } catch (e) {\n        body = {};\n      }\n\n      if (err) {\n        const error = new Error();\n        error.ErrorMessage = body.ErrorMessage || err.message;\n        error.ErrorIdentifier = body.ErrorIdentifier;\n        error.statusCode = err.status || null;\n        error.response = result || null;\n        error.message = 'Unsuccessful: ' + error.statusCode + ' ' + error.ErrorMessage;\n        return ret(error);\n      }\n\n      return ret(null, {\n        response: result,\n        body: body\n      });\n    });\n  });\n};\n/*\n *\n * MailjetResource constructor\n *\n * This class creates a function that can be build through method chaining\n *\n * @method {String} http method\n * @func {String} resource/path to be sent\n * @context {MailjetClient[instance]} parent client\n */\n\n\nfunction MailjetResource(method, func, options, context) {\n  this.base = func;\n  this.callUrl = func;\n  this.options = options || context.options;\n  this.resource = func.toLowerCase();\n  this.lastAdded = RESOURCE;\n  var self = context;\n  /*\n  It can be REST or nothing if we only know the resource\n  */\n\n  this.subPath = function () {\n    if (func.toLowerCase() !== 'send' && func.indexOf('sms') === -1) {\n      return 'REST';\n    }\n\n    return '';\n  }();\n  /**\n   *\n   * result.\n   *\n   * @params (optional) {Object Littteral} parameters to be sent to the server\n   * @callback (optional) {Function} called on response or error\n   */\n\n\n  var that = this;\n\n  this.result = function (params, callback) {\n    params = params || {};\n\n    if (typeof params === 'function') {\n      callback = params;\n      params = {};\n    }\n    /*\n    We build the querystring depending on the parameters. if the user explicitly mentionned\n    a filters property, we pass it to the url\n    */\n\n\n    var path = self.path(that.callUrl, that.subPath, function () {\n      if (params.filters) {\n        var ret = params.filters;\n        delete params.filters;\n        return ret;\n      } else if (method === 'get') {\n        return params;\n      } else {\n        return {};\n      }\n    }(), that.options);\n    var secured = null;\n\n    if (that.options && 'secured' in that.options) {\n      secured = that.options.secured;\n    } else {\n      secured = self.config.secured;\n    }\n\n    var perform_api_call = null;\n\n    if (that.options && 'perform_api_call' in that.options) {\n      perform_api_call = that.options.perform_api_call;\n    } else {\n      perform_api_call = self.config.perform_api_call;\n    }\n\n    that.callUrl = that.base;\n    self.lastAdded = RESOURCE;\n    return self.httpRequest(method, (secured ? 'https' : 'http') + '://' + path, params, callback, perform_api_call);\n  };\n}\n/**\n *\n * id.\n *\n * Add an ID and prevent invalid id chaining\n *\n * @value {String/Number} append an id to the path\n * @return the MailjetResource instance to allow method chaining\n *\n */\n\n\nMailjetResource.prototype.id = function (value) {\n  if (this.lastAdded === ID && DEBUG_MODE) {\n    console.warn('[WARNING] your request may fail due to invalid id chaining');\n  }\n\n  this.callUrl = _path.join(this.callUrl, value.toString());\n  this.lastAdded = ID;\n  return this;\n};\n/**\n *\n * action.\n *\n * Add an Action and prevent invalid action chaining\n *\n * @value {String} append an action to the path\n * @return the MailjetResource instance to allow method chaining\n *\n */\n\n\nMailjetResource.prototype.action = function (name) {\n  if (this.lastAdded === ACTION && DEBUG_MODE) {\n    console.warn('[WARNING] your request may fail due to invalid action chaining');\n  }\n\n  this.callUrl = _path.join(this.callUrl, name);\n  this.action = name.toLowerCase();\n  this.lastAdded = ACTION;\n\n  if (this.action.toLowerCase() === 'csvdata') {\n    this.action = 'csvdata/text:plain';\n  } else if (this.action.toLowerCase() === 'csverror') {\n    this.action = 'csverror/text:csv';\n  }\n\n  var self = this;\n\n  this.subPath = function () {\n    if (self.resource === 'contactslist' && self.action === 'csvdata/text:plain' || self.resource === 'batchjob' && self.action === 'csverror/text:csv') {\n      return 'DATA';\n    } else {\n      return self.subPath;\n    }\n  }();\n\n  return self;\n};\n/**\n *\n * request.\n *\n * @parmas {Object literal} method parameters\n * @callback (optional) {Function} triggered when done\n *\n * @return {String} the server response\n */\n\n\nMailjetResource.prototype.request = function (params, callback) {\n  return this.result(params, callback);\n};\n/*\n * post.\n *\n * @func {String} required Mailjet API function to be used (can contain a whole action path)\n *\n * @returns a function that make an httpRequest for each call\n */\n\n\nMailjetClient.prototype.post = function (func, options) {\n  return new MailjetResource('post', func, options, this);\n};\n/*\n * get.\n *\n * @func {String} required Mailjet API function to be used (can contain a whole action path)\n *\n * @returns a function that make an httpRequest for each call\n */\n\n\nMailjetClient.prototype.get = function (func, options) {\n  return new MailjetResource('get', func, options, this);\n};\n/*\n * delete.\n *\n * @func {String} required Mailjet API function to be used (can contain a whole action path)\n *\n * @returns a function that make an httpRequest for each call\n */\n\n\nMailjetClient.prototype.delete = function (func, options) {\n  return new MailjetResource('delete', func, options, this);\n};\n/*\n * put.\n *\n * @func {String} required Mailjet API function to be used (can contain a whole action path)\n *\n * @returns a function that make an httpRequest for each call\n */\n\n\nMailjetClient.prototype.put = function (func, options) {\n  return new MailjetResource('put', func, options, this);\n};\n/*\n * Exports the Mailjet client.\n *\n * you can require it like so:\n * var mj = require ('./mailjet-client')\n *\n * or for the bleeding edge developpers out there:\n * import mj from './mailjet-client'\n */\n\n\nmodule.exports = MailjetClient;","map":null,"metadata":{},"sourceType":"script"}